<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Explota-Color üåà</title>
<style>
  :root {
    --bg: #0f172a;
    --gap: 6px;
    --radius: 14px;

    /* Colores vibrantes */
    --c0: #ff4d4f;
    --c1: #3b82f6;
    --c2: #22c55e;
    --c3: #f59e0b;
    --c4: #a855f7;

    --text: #e5e7eb;
    --muted: #9ca3af;
    
    /* Safe areas para iPhone */
    --safe-top: max(10px, env(safe-area-inset-top));
    --safe-bottom: max(10px, env(safe-area-inset-bottom));
    --safe-left: max(10px, env(safe-area-inset-left));
    --safe-right: max(10px, env(safe-area-inset-right));
  }

  * { 
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    margin: 0;
    padding: 0;
  }
  
  html { 
    height: 100%; 
    height: -webkit-fill-available;
  }
  
  body {
    min-height: 100vh;
    min-height: -webkit-fill-available;
    overflow: hidden;
    background: linear-gradient(180deg, #667eea, #764ba2);
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    padding: var(--safe-top) var(--safe-left) var(--safe-bottom) var(--safe-right);
  }

  /* Header compacto para iPhone */
  header {
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 8px;
    margin-bottom: 8px;
  }

  .header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .title {
    font-weight: 700;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .title .logo {
    font-size: 18px;
  }

  .stats {
    display: flex;
    gap: 6px;
    font-size: 11px;
    font-weight: 600;
  }

  .pill {
    background: rgba(255,255,255,0.15);
    padding: 3px 8px;
    border-radius: 999px;
    display: flex;
    align-items: center;
    gap: 3px;
  }

  .controls {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }

  .controls select,
  .controls button {
    flex: 1;
    min-width: 0;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: #fff;
    font-weight: 600;
    font-size: 11px;
  }

  button:active {
    transform: scale(0.95);
  }

  /* Tablero responsive */
  .board-wrap {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 8px;
  }

  .board {
    --cols: 6;
    --rows: 8;
    width: 100%;
    max-width: 380px;
    aspect-ratio: 6/8;
    display: grid;
    grid-template-columns: repeat(var(--cols), 1fr);
    grid-template-rows: repeat(var(--rows), 1fr);
    gap: var(--gap);
    padding: 10px;
    border-radius: 16px;
    background: rgba(0,0,0,0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  /* Fichas responsivas */
  .tile {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: min(5vw, 28px);
    border-radius: var(--radius);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    cursor: pointer;
    transition: transform 0.15s;
    position: relative;
  }

  .tile:active {
    transform: scale(0.9);
  }

  /* Colores correctos */
  .c0 { background: linear-gradient(135deg, #ff6b6b, #ff4d4f); }
  .c1 { background: linear-gradient(135deg, #4ecdc4, #3b82f6); }
  .c2 { background: linear-gradient(135deg, #4ade80, #22c55e); }
  .c3 { background: linear-gradient(135deg, #ffd93d, #f59e0b); }
  .c4 { background: linear-gradient(135deg, #c77dff, #a855f7); }

  /* Pelota especial con glow del mismo color */
  .ball {
    animation: pulse 1s ease-in-out infinite;
    box-shadow: 
      0 0 20px currentColor,
      0 0 40px currentColor,
      0 2px 4px rgba(0,0,0,0.3);
  }

  .ball.c0 { color: #ff4d4f; }
  .ball.c1 { color: #3b82f6; }
  .ball.c2 { color: #22c55e; }
  .ball.c3 { color: #f59e0b; }
  .ball.c4 { color: #a855f7; }

  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  /* Animaci√≥n de ca√≠da */
  .falling {
    animation: fall var(--fall-duration, 0.3s) cubic-bezier(0.4, 0, 0.2, 1) both;
    animation-delay: var(--fall-delay, 0s);
  }

  @keyframes fall {
    from {
      transform: translateY(calc(var(--fall-distance, -50px) * -1));
      opacity: 0.5;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  /* Nueva ficha */
  .new-tile {
    animation: dropNew 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) both;
    animation-delay: var(--new-delay, 0s);
  }

  @keyframes dropNew {
    from {
      transform: translateY(-150%) scale(0.5) rotate(180deg);
      opacity: 0;
    }
    to {
      transform: translateY(0) scale(1) rotate(0deg);
      opacity: 1;
    }
  }

  /* Explosi√≥n */
  .exploding {
    animation: explode 0.3s ease-out forwards;
  }

  @keyframes explode {
    to {
      transform: scale(0);
      opacity: 0;
    }
  }

  /* Rebote */
  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
  }

  /* Toast */
  .toast {
    position: fixed;
    left: 50%;
    top: var(--safe-top);
    transform: translateX(-50%);
    background: rgba(255,255,255,0.95);
    color: #1a1a1a;
    padding: 8px 16px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 13px;
    z-index: 9999;
    animation: toastSlide 1.5s ease forwards;
  }

  @keyframes toastSlide {
    0% { transform: translateX(-50%) translateY(-100px); opacity: 0; }
    20%, 80% { transform: translateX(-50%) translateY(20px); opacity: 1; }
    100% { transform: translateX(-50%) translateY(-100px); opacity: 0; }
  }

  /* Modal */
  .modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    padding: 20px;
  }

  .modal-card {
    background: white;
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    color: #1a1a1a;
    max-width: 90%;
    animation: modalPop 0.3s ease;
  }

  @keyframes modalPop {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 {
    margin: 0 0 12px 0;
    font-size: 24px;
    color: #764ba2;
  }

  .modal .emoji {
    font-size: 48px;
    margin-bottom: 12px;
  }

  .modal button {
    margin-top: 12px;
    padding: 10px 20px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
  }

  /* Footer con contador de partidas */
  footer {
    text-align: center;
    font-size: 11px;
    padding: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    margin-top: 8px;
  }

  .games-counter {
    font-weight: 700;
    color: #ffd93d;
    font-size: 13px;
    margin-bottom: 4px;
  }

  .hint {
    color: #4ade80;
    font-weight: 600;
  }

  /* Part√≠cula */
  .particle {
    position: fixed;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9998;
    animation: particle 0.6s ease-out forwards;
  }

  @keyframes particle {
    to {
      transform: translate(var(--dx), var(--dy)) scale(0);
      opacity: 0;
    }
  }

  /* Media queries para iPhone */
  @media screen and (max-width: 390px) {
    .board {
      max-width: calc(100vw - 32px);
    }
    
    .tile {
      font-size: min(6vw, 24px);
    }
  }

  @media screen and (max-height: 700px) {
    header { padding: 6px; }
    .header-row { margin-bottom: 4px; }
    .controls { gap: 3px; }
    .board { gap: 4px; padding: 8px; }
  }

  /* iPhone SE */
  @media screen and (max-width: 375px) and (max-height: 667px) {
    .title { font-size: 12px; }
    .stats { font-size: 10px; }
    .controls select, .controls button { font-size: 10px; padding: 5px 6px; }
  }
</style>
</head>
<body>
  <header>
    <div class="header-row">
      <div class="title">
        <span class="logo">üåà</span>
        <span>Explota-Color</span>
      </div>
      <div class="stats">
        <div class="pill">üéØ <span id="target">0</span></div>
        <div class="pill">‚≠ê <span id="score">0</span></div>
        <div class="pill">üëÜ <span id="moves">0</span></div>
      </div>
    </div>
    <div class="controls">
      <select id="levelSel">
        <option value="baby">üë∂ Beb√©</option>
        <option value="easy">üê£ F√°cil</option>
        <option value="normal" selected>ü¶Ñ Normal</option>
      </select>
      <select id="themeSel">
        <option value="frutas">üçì Frutas</option>
        <option value="animales">üêµ Animales</option>
        <option value="caras">üòä Caras</option>
      </select>
      <button id="newBtn">‚ú® Nuevo</button>
      <button id="soundBtn">üîä</button>
      <button id="voiceBtn">üó£Ô∏è</button>
    </div>
  </header>

  <div class="board-wrap">
    <div id="board" class="board"></div>
  </div>

  <footer>
    <div class="games-counter">üéÆ Partidas restantes: <span id="gamesLeft">5</span> de 5</div>
    <div class="hint">‚ú® Toca 2+ iguales ‚Ä¢ 5+ = pelota m√°gica</div>
  </footer>

<script>
(function(){
  'use strict';
  
  // Configuraci√≥n
  const COLS = 6;
  const ROWS = 8;
  const MAX_GAMES = 5;

  const EMOJI_THEMES = {
    frutas: [
      { emoji: 'üçì', name: 'fresa' },
      { emoji: 'ü´ê', name: 'ar√°ndano' },
      { emoji: 'ü•ù', name: 'kiwi' },
      { emoji: 'üçå', name: 'pl√°tano' },
      { emoji: 'üçá', name: 'uvas' }
    ],
    animales: [
      { emoji: 'üêµ', name: 'mono' },
      { emoji: 'üê∏', name: 'rana' },
      { emoji: 'ü¶Å', name: 'le√≥n' },
      { emoji: 'üê•', name: 'pollito' },
      { emoji: 'üê∑', name: 'cerdito' }
    ],
    caras: [
      { emoji: 'üòä', name: 'feliz' },
      { emoji: 'üòé', name: 'cool' },
      { emoji: 'ü§ó', name: 'abrazo' },
      { emoji: 'üòã', name: 'rico' },
      { emoji: 'ü•≥', name: 'fiesta' }
    ]
  };

  const LEVELS = {
    baby: { target: 500, moves: 50 },
    easy: { target: 1500, moves: 35 },
    normal: { target: 3000, moves: 25 }
  };

  // Sistema de sonido
  class SoundSystem {
    constructor() {
      this.enabled = true;
      this.audioCtx = null;
      this.init();
    }

    init() {
      try {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        console.warn('Audio no disponible');
      }
    }

    play(freq, duration = 0.2) {
      if (!this.enabled || !this.audioCtx) return;
      try {
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.start();
        osc.stop(this.audioCtx.currentTime + duration);
      } catch (e) {}
    }

    playPop() { this.play(600, 0.1); }
    playSuccess() { 
      [523, 659, 784].forEach((f, i) => {
        setTimeout(() => this.play(f, 0.15), i * 50);
      });
    }
    playError() { this.play(200, 0.3); }
  }

  // Sistema de voz CORREGIDO
  class VoiceSystem {
    constructor() {
      this.enabled = false; // Empieza desactivado
      this.synth = window.speechSynthesis;
    }

    speak(text, force = false) {
      if (!this.enabled && !force) return;
      if (!this.synth) return;
      
      try {
        // Cancelar voces anteriores
        this.synth.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'es-ES';
        utterance.pitch = 1.3;
        utterance.rate = 0.9;
        utterance.volume = 0.7;
        
        // Esperar un momento para que el sintetizador est√© listo
        setTimeout(() => {
          this.synth.speak(utterance);
        }, 100);
      } catch (e) {
        console.warn('Error en voz:', e);
      }
    }

    toggle() {
      this.enabled = !this.enabled;
      if (this.enabled) {
        this.speak('¬°Voz activada!');
      }
      return this.enabled;
    }
  }

  // Estado del juego
  let state = {
    grid: [],
    score: 0,
    movesLeft: 25,
    target: 3000,
    level: 'normal',
    theme: 'frutas',
    animating: false,
    gamesLeft: MAX_GAMES
  };

  // Cargar partidas restantes del localStorage
  const savedGames = localStorage.getItem('gamesLeft');
  if (savedGames !== null) {
    state.gamesLeft = parseInt(savedGames);
  }

  let currentTheme = EMOJI_THEMES.frutas;
  const soundSystem = new SoundSystem();
  const voiceSystem = new VoiceSystem();

  // Elementos DOM
  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const movesEl = document.getElementById('moves');
  const targetEl = document.getElementById('target');
  const gamesLeftEl = document.getElementById('gamesLeft');
  const newBtn = document.getElementById('newBtn');
  const levelSel = document.getElementById('levelSel');
  const themeSel = document.getElementById('themeSel');
  const soundBtn = document.getElementById('soundBtn');
  const voiceBtn = document.getElementById('voiceBtn');

  // Renderizado CORREGIDO
  function render(animateChanges = false) {
    boardEl.innerHTML = '';
    const fragment = document.createDocumentFragment();
    
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const cell = state.grid[y][x];
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.x = x;
        tile.dataset.y = y;
        
        if (!cell) {
          tile.style.visibility = 'hidden';
        } else {
          // Usar el color correcto
          tile.classList.add(`c${cell.color}`);
          
          if (cell.kind === 'ball') {
            tile.classList.add('ball');
            // Mostrar emoji especial para pelota
            tile.textContent = '‚ö°';
          } else {
            tile.textContent = currentTheme[cell.color].emoji;
          }
          
          // Animaciones
          if (animateChanges && cell.fallFrom !== undefined) {
            const distance = (cell.fallFrom - y) * 50;
            tile.style.setProperty('--fall-distance', `${distance}px`);
            tile.style.setProperty('--fall-duration', `${0.3 + (cell.fallFrom - y) * 0.05}s`);
            tile.style.setProperty('--fall-delay', `${x * 0.02}s`);
            tile.classList.add('falling');
            delete cell.fallFrom;
          }
          
          if (animateChanges && cell.isNew) {
            tile.style.setProperty('--new-delay', `${(x * 0.03) + 0.1}s`);
            tile.classList.add('new-tile');
            delete cell.isNew;
          }
        }
        
        fragment.appendChild(tile);
      }
    }
    
    boardEl.appendChild(fragment);
  }

  // Click en ficha
  boardEl.addEventListener('click', (e) => {
    if (state.animating) return;
    
    const tile = e.target.closest('.tile');
    if (!tile) return;
    
    const x = parseInt(tile.dataset.x);
    const y = parseInt(tile.dataset.y);
    const cell = state.grid[y]?.[x];
    
    if (!cell) return;
    
    if (cell.kind === 'ball') {
      handleBallClick(x, y, cell.color);
    } else {
      handleNormalClick(x, y, cell.color);
    }
  });

  // Manejar click normal CORREGIDO
  function handleNormalClick(x, y, color) {
    const group = findGroup(x, y, color);
    
    if (group.length < 2) {
      const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
      if (tile) {
        tile.style.animation = 'bounce 0.3s';
        setTimeout(() => tile.style.animation = '', 300);
      }
      soundSystem.playError();
      return;
    }
    
    state.animating = true;
    spendMove();
    
    // Crear pelota si el grupo es >= 5
    if (group.length >= 5) {
      animateExplosion(group.filter(([gx, gy]) => !(gx === x && gy === y)));
      
      setTimeout(() => {
        // Eliminar todas excepto la central
        for (const [gx, gy] of group) {
          if (!(gx === x && gy === y)) {
            spawnParticles(gx, gy, color);
            state.grid[gy][gx] = null;
          }
        }
        
        // Convertir la central en pelota DEL MISMO COLOR
        state.grid[y][x] = { kind: 'ball', color: color };
        
        soundSystem.playSuccess();
        voiceSystem.speak('¬°Pelota m√°gica!');
        showToast('¬°Pelota m√°gica! ‚ö°');
        
        applyGravity();
        fillEmpty();
        render(true);
        
        setTimeout(() => {
          state.animating = false;
          checkGameState();
        }, 600);
      }, 300);
      
      addScore(100 + group.length * 10);
      return;
    }
    
    // Grupo normal
    animateExplosion(group);
    
    setTimeout(() => {
      for (const [gx, gy] of group) {
        spawnParticles(gx, gy, color);
        state.grid[gy][gx] = null;
      }
      
      soundSystem.playPop();
      
      if (group.length >= 3) {
        voiceSystem.speak('¬°Bien hecho!');
      }
      
      applyGravity();
      fillEmpty();
      render(true);
      
      setTimeout(() => {
        state.animating = false;
        checkGameState();
      }, 600);
    }, 300);
    
    addScore(group.length * 15);
  }

  // Manejar click en pelota CORREGIDO
  function handleBallClick(x, y, color) {
    state.animating = true;
    spendMove();
    
    const ballCluster = findBallCluster(x, y);
    
    if (ballCluster.length >= 2) {
      // Limpieza total
      voiceSystem.speak('¬°Explosi√≥n total!');
      
      setTimeout(() => {
        for (let py = 0; py < ROWS; py++) {
          for (let px = 0; px < COLS; px++) {
            if (state.grid[py][px]) {
              if (state.grid[py][px].kind === 'normal') {
                spawnParticles(px, py, state.grid[py][px].color);
                state.grid[py][px] = null;
              } else if (ballCluster.some(([bx, by]) => bx === px && by === py)) {
                state.grid[py][px] = null;
              }
            }
          }
        }
        
        soundSystem.playSuccess();
        applyGravity();
        fillEmpty();
        render(true);
        
        setTimeout(() => {
          state.animating = false;
          checkGameState();
        }, 600);
      }, 400);
      
      addScore(500);
    } else {
      // Eliminar todas las fichas DEL MISMO COLOR que la pelota
      const targets = [];
      for (let py = 0; py < ROWS; py++) {
        for (let px = 0; px < COLS; px++) {
          const cell = state.grid[py][px];
          if (cell && cell.kind === 'normal' && cell.color === color) {
            targets.push([px, py]);
          }
        }
      }
      
      animateExplosion(targets);
      
      setTimeout(() => {
        state.grid[y][x] = null; // Eliminar la pelota
        for (const [tx, ty] of targets) {
          spawnParticles(tx, ty, color);
          state.grid[ty][tx] = null;
        }
        
        soundSystem.playSuccess();
        voiceSystem.speak('¬°Explosi√≥n de color!');
        showToast(`¬°Boom! ${currentTheme[color].emoji}`);
        
        applyGravity();
        fillEmpty();
        render(true);
        
        setTimeout(() => {
          state.animating = false;
          checkGameState();
        }, 600);
      }, 400);
      
      addScore(targets.length * 25);
    }
  }

  // Gravedad
  function applyGravity() {
    for (let x = 0; x < COLS; x++) {
      const column = [];
      
      for (let y = 0; y < ROWS; y++) {
        if (state.grid[y][x]) {
          column.push({
            cell: state.grid[y][x],
            originalY: y
          });
        }
      }
      
      for (let y = 0; y < ROWS; y++) {
        state.grid[y][x] = null;
      }
      
      let writePos = ROWS - 1;
      for (let i = column.length - 1; i >= 0; i--) {
        const item = column[i];
        state.grid[writePos][x] = item.cell;
        
        if (writePos > item.originalY) {
          state.grid[writePos][x].fallFrom = item.originalY;
        }
        
        writePos--;
      }
    }
  }

  // Rellenar vac√≠os
  function fillEmpty() {
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (!state.grid[y][x]) {
          state.grid[y][x] = {
            kind: 'normal',
            color: Math.floor(Math.random() * 5),
            isNew: true
          };
        }
      }
    }
  }

  // Buscar grupo
  function findGroup(startX, startY, color) {
    const visited = new Set();
    const stack = [[startX, startY]];
    const group = [];
    
    while (stack.length > 0) {
      const [x, y] = stack.pop();
      const key = `${x},${y}`;
      
      if (visited.has(key)) continue;
      visited.add(key);
      
      const cell = state.grid[y]?.[x];
      if (!cell || cell.kind !== 'normal' || cell.color !== color) continue;
      
      group.push([x, y]);
      
      if (x > 0) stack.push([x - 1, y]);
      if (x < COLS - 1) stack.push([x + 1, y]);
      if (y > 0) stack.push([x, y - 1]);
      if (y < ROWS - 1) stack.push([x, y + 1]);
    }
    
    return group;
  }

  // Buscar cluster de pelotas
  function findBallCluster(startX, startY) {
    const visited = new Set();
    const stack = [[startX, startY]];
    const cluster = [];
    
    while (stack.length > 0) {
      const [x, y] = stack.pop();
      const key = `${x},${y}`;
      
      if (visited.has(key)) continue;
      visited.add(key);
      
      const cell = state.grid[y]?.[x];
      if (!cell || cell.kind !== 'ball') continue;
      
      cluster.push([x, y]);
      
      if (x > 0) stack.push([x - 1, y]);
      if (x < COLS - 1) stack.push([x + 1, y]);
      if (y > 0) stack.push([x, y - 1]);
     if (y < ROWS - 1) stack.push([x, y + 1]);
   }
   
   return cluster;
 }

 // Animaciones
 function animateExplosion(cells) {
   for (const [x, y] of cells) {
     const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
     if (tile) {
       tile.classList.add('exploding');
     }
   }
 }

 // Part√≠culas
 function spawnParticles(x, y, color) {
   const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
   if (!tile) return;
   
   const rect = tile.getBoundingClientRect();
   const colors = ['#ff4d4f', '#3b82f6', '#22c55e', '#f59e0b', '#a855f7'];
   
   for (let i = 0; i < 6; i++) {
     const particle = document.createElement('div');
     particle.className = 'particle';
     particle.style.left = rect.left + rect.width / 2 + 'px';
     particle.style.top = rect.top + rect.height / 2 + 'px';
     particle.style.background = colors[color];
     
     const angle = (Math.PI * 2 * i) / 6;
     const distance = 40 + Math.random() * 30;
     particle.style.setProperty('--dx', Math.cos(angle) * distance + 'px');
     particle.style.setProperty('--dy', Math.sin(angle) * distance + 'px');
     
     document.body.appendChild(particle);
     setTimeout(() => particle.remove(), 600);
   }
 }

 // UI
 function showToast(message) {
   const existing = document.querySelector('.toast');
   if (existing) existing.remove();
   
   const toast = document.createElement('div');
   toast.className = 'toast';
   toast.textContent = message;
   document.body.appendChild(toast);
   setTimeout(() => toast.remove(), 1500);
 }

 function addScore(points) {
   state.score += points;
   updateUI();
   showToast(`+${points} ‚≠ê`);
 }

 function spendMove() {
   if (state.movesLeft > 0) {
     state.movesLeft--;
     updateUI();
   }
 }

 function updateUI() {
   scoreEl.textContent = state.score;
   movesEl.textContent = state.movesLeft;
   targetEl.textContent = state.target;
   gamesLeftEl.textContent = state.gamesLeft;
 }

 // NUEVO: Control de l√≠mite de partidas
 function checkGamesLimit() {
   if (state.gamesLeft <= 0) {
     // Mostrar modal de l√≠mite alcanzado
     voiceSystem.speak('¬°No hay m√°s partidas! Vuelve ma√±ana', true);
     
     const modal = document.createElement('div');
     modal.className = 'modal';
     modal.innerHTML = `
       <div class="modal-card">
         <div class="emoji">üõë</div>
         <h2>¬°No hay m√°s partidas!</h2>
         <p>Has jugado todas tus partidas de hoy.</p>
         <p>¬°Vuelve ma√±ana para jugar m√°s!</p>
         <button onclick="location.reload()">Entendido</button>
       </div>
     `;
     document.body.appendChild(modal);
     
     // Bloquear el juego
     state.animating = true;
     return false;
   }
   return true;
 }

 function consumeGame() {
   state.gamesLeft--;
   localStorage.setItem('gamesLeft', state.gamesLeft);
   updateUI();
 }

 // Resetear partidas diariamente
 function checkDailyReset() {
   const today = new Date().toDateString();
   const lastReset = localStorage.getItem('lastReset');
   
   if (lastReset !== today) {
     state.gamesLeft = MAX_GAMES;
     localStorage.setItem('gamesLeft', MAX_GAMES);
     localStorage.setItem('lastReset', today);
   }
 }

 // Verificar estado del juego
 function checkGameState() {
   if (state.score >= state.target) {
     showWin();
   } else if (state.movesLeft === 0) {
     showGameOver();
   }
 }

 function showWin() {
   soundSystem.playSuccess();
   voiceSystem.speak('¬°Ganaste! ¬°Eres incre√≠ble!');
   
   const modal = document.createElement('div');
   modal.className = 'modal';
   modal.innerHTML = `
     <div class="modal-card">
       <div class="emoji">üèÜ</div>
       <h2>¬°VICTORIA!</h2>
       <p>¬°Conseguiste ${state.score} puntos!</p>
       <p>Te quedan ${state.gamesLeft} partidas</p>
       <button onclick="window.startNewGame()">üéÆ Jugar de nuevo</button>
     </div>
   `;
   document.body.appendChild(modal);
 }

 function showGameOver() {
   voiceSystem.speak('¬°Se acab√≥! Int√©ntalo de nuevo');
   
   const modal = document.createElement('div');
   modal.className = 'modal';
   modal.innerHTML = `
     <div class="modal-card">
       <div class="emoji">üò¢</div>
       <h2>¬°Se acab√≥!</h2>
       <p>Conseguiste ${state.score} puntos</p>
       <p>Te faltan ${state.target - state.score} puntos</p>
       <p>Te quedan ${state.gamesLeft} partidas</p>
       <button onclick="window.startNewGame()">üéÆ Intentar de nuevo</button>
     </div>
   `;
   document.body.appendChild(modal);
 }

 // Funci√≥n global para empezar nuevo juego
 window.startNewGame = function() {
   // Cerrar modal
   const modal = document.querySelector('.modal');
   if (modal) modal.remove();
   
   // Verificar l√≠mite de partidas
   if (!checkGamesLimit()) return;
   
   // Consumir una partida
   consumeGame();
   
   // Reiniciar
   init();
   showToast('¬°Nueva partida! üéÆ');
 };

 // Inicializaci√≥n CORREGIDA
 function init() {
   state.level = levelSel.value;
   state.theme = themeSel.value;
   currentTheme = EMOJI_THEMES[state.theme];
   
   const config = LEVELS[state.level];
   state.target = config.target;
   state.movesLeft = config.moves;
   state.score = 0;
   state.animating = false;
   
   // Generar tablero con algoritmo mejorado
   generateBoard();
   
   render(false);
   updateUI();
 }

 // NUEVO: Generaci√≥n de tablero mejorada para evitar bugs
 function generateBoard() {
   state.grid = [];
   
   for (let y = 0; y < ROWS; y++) {
     state.grid[y] = [];
     for (let x = 0; x < COLS; x++) {
       // Evitar grupos grandes al inicio
       let color;
       const forbidden = new Set();
       
       // Revisar izquierda
       if (x >= 2 && 
           state.grid[y][x-1].color === state.grid[y][x-2].color) {
         forbidden.add(state.grid[y][x-1].color);
       }
       
       // Revisar arriba
       if (y >= 2 && 
           state.grid[y-1][x].color === state.grid[y-2][x].color) {
         forbidden.add(state.grid[y-1][x].color);
       }
       
       // Elegir color evitando los prohibidos
       const availableColors = [0,1,2,3,4].filter(c => !forbidden.has(c));
       color = availableColors[Math.floor(Math.random() * availableColors.length)];
       
       state.grid[y][x] = {
         kind: 'normal',
         color: color
       };
     }
   }
   
   // Asegurar que hay movimientos posibles
   ensurePlayableMoves();
 }

 // Asegurar movimientos jugables
 function ensurePlayableMoves() {
   let hasMove = false;
   
   // Verificar si hay alg√∫n grupo de 2+
   for (let y = 0; y < ROWS && !hasMove; y++) {
     for (let x = 0; x < COLS && !hasMove; x++) {
       const group = findGroup(x, y, state.grid[y][x].color);
       if (group.length >= 2) {
         hasMove = true;
       }
     }
   }
   
   // Si no hay movimientos, crear uno
   if (!hasMove) {
     const x = Math.floor(Math.random() * (COLS - 1));
     const y = Math.floor(Math.random() * ROWS);
     const color = state.grid[y][x].color;
     state.grid[y][x + 1].color = color;
   }
 }

 // Event listeners CORREGIDOS
 newBtn.addEventListener('click', () => {
   if (!checkGamesLimit()) return;
   
   if (state.score > 0) {
     if (!confirm('¬øEmpezar nueva partida? Perder√°s el progreso actual.')) {
       return;
     }
   }
   
   consumeGame();
   init();
   showToast('¬°Nueva partida! üéÆ');
 });

 levelSel.addEventListener('change', () => {
   init();
   showToast(`Nivel: ${levelSel.options[levelSel.selectedIndex].text}`);
 });

 themeSel.addEventListener('change', () => {
   currentTheme = EMOJI_THEMES[themeSel.value];
   render(false);
   showToast(`Tema: ${themeSel.options[themeSel.selectedIndex].text}`);
 });

 soundBtn.addEventListener('click', () => {
   soundSystem.enabled = !soundSystem.enabled;
   soundBtn.textContent = soundSystem.enabled ? 'üîä' : 'üîá';
   showToast(soundSystem.enabled ? 'Sonido ON' : 'Sonido OFF');
 });

 // Bot√≥n de voz CORREGIDO
 voiceBtn.addEventListener('click', () => {
   const enabled = voiceSystem.toggle();
   voiceBtn.textContent = enabled ? 'üó£Ô∏è' : 'üîï';
   showToast(enabled ? 'Voz ON' : 'Voz OFF');
 });

 // Iniciar juego
 checkDailyReset();
 checkGamesLimit();
 init();
 showToast('¬°Bienvenido! üåà');

 // Auto-tests m√≠nimos
 (function selfTest() {
   console.log('üéÆ Explota-Color iniciado correctamente');
   console.log('üìä Partidas restantes:', state.gamesLeft);
   console.log('üîä Audio:', soundSystem.audioCtx ? 'OK' : 'No disponible');
   console.log('üó£Ô∏è Voz:', voiceSystem.synth ? 'OK' : 'No disponible');
 })();

})();
</script>
</body>
</html>
