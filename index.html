<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Explota-Color üåà</title>
<style>
  :root {
    --bg: #0f172a;
    --gap: 6px;
    --radius: 14px;

    /* Colores vibrantes */
    --c0: #ff4d4f;
    --c1: #3b82f6;
    --c2: #22c55e;
    --c3: #f59e0b;
    --c4: #a855f7;

    --text: #e5e7eb;
    --muted: #9ca3af;
    
    /* Safe areas para iPhone */
    --safe-top: max(10px, env(safe-area-inset-top));
    --safe-bottom: max(10px, env(safe-area-inset-bottom));
    --safe-left: max(10px, env(safe-area-inset-left));
    --safe-right: max(10px, env(safe-area-inset-right));
  }

  * { 
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    margin: 0;
    padding: 0;
  }
  
  html { 
    height: 100%; 
    height: -webkit-fill-available;
  }
  
  body {
    min-height: 100vh;
    min-height: -webkit-fill-available;
    overflow: hidden;
    background: linear-gradient(180deg, #667eea, #764ba2);
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    padding: var(--safe-top) var(--safe-left) var(--safe-bottom) var(--safe-right);
  }

  /* Header compacto para iPhone */
  header {
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 8px;
    margin-bottom: 8px;
  }

  .header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .title {
    font-weight: 700;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .title .logo {
    font-size: 18px;
  }

  .level-indicator {
    background: linear-gradient(135deg, #ffd700, #ffed4e);
    color: #1a1a1a;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 800;
    margin-left: 6px;
  }

  .stats {
    display: flex;
    gap: 6px;
    font-size: 11px;
    font-weight: 600;
  }

  .pill {
    background: rgba(255,255,255,0.15);
    padding: 3px 8px;
    border-radius: 999px;
    display: flex;
    align-items: center;
    gap: 3px;
  }

  .controls {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }

  .controls select,
  .controls button {
    flex: 1;
    min-width: 0;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: #fff;
    font-weight: 600;
    font-size: 11px;
  }

  button:active {
    transform: scale(0.95);
  }

  /* Tablero responsive */
  .board-wrap {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 8px;
  }

  .board {
    --cols: 6;
    --rows: 8;
    width: 100%;
    max-width: 380px;
    aspect-ratio: 6/8;
    display: grid;
    grid-template-columns: repeat(var(--cols), 1fr);
    grid-template-rows: repeat(var(--rows), 1fr);
    gap: var(--gap);
    padding: 10px;
    border-radius: 16px;
    background: rgba(0,0,0,0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  /* Fichas responsivas */
  .tile {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: min(5vw, 28px);
    border-radius: var(--radius);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    cursor: pointer;
    transition: transform 0.15s;
    position: relative;
  }

  .tile:active {
    transform: scale(0.9);
  }

  /* Colores correctos - Solo los primeros 3 para nivel 1 */
  .c0 { background: linear-gradient(135deg, #ff6b6b, #ff4d4f); }
  .c1 { background: linear-gradient(135deg, #ffd93d, #f59e0b); }
  .c2 { background: linear-gradient(135deg, #4ecdc4, #3b82f6); }
  .c3 { background: linear-gradient(135deg, #4ade80, #22c55e); }
  .c4 { background: linear-gradient(135deg, #c77dff, #a855f7); }

  /* PELOTA ESPECIAL - Bal√≥n de f√∫tbol girando */
  .ball {
    background: conic-gradient(
      from 0deg,
      currentColor 0deg 30deg,
      white 30deg 60deg,
      currentColor 60deg 90deg,
      white 90deg 120deg,
      currentColor 120deg 150deg,
      white 150deg 180deg,
      currentColor 180deg 210deg,
      white 210deg 240deg,
      currentColor 240deg 270deg,
      white 270deg 300deg,
      currentColor 300deg 330deg,
      white 330deg 360deg
    ) !important;
    animation: rotateBall 2s linear infinite;
    box-shadow: 
      0 0 30px currentColor,
      0 0 50px currentColor,
      inset 0 0 20px rgba(0,0,0,0.3),
      0 4px 8px rgba(0,0,0,0.4);
    border: 2px solid rgba(255,255,255,0.3);
  }

  .ball.c0 { color: #ff4d4f; }
  .ball.c1 { color: #f59e0b; }
  .ball.c2 { color: #3b82f6; }
  .ball.c3 { color: #22c55e; }
  .ball.c4 { color: #a855f7; }

  .ball::before {
    content: '‚öΩ';
    font-size: 0.7em;
    position: absolute;
    animation: pulse 1s ease-in-out infinite;
  }

  @keyframes rotateBall {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.2); opacity: 1; }
  }

  /* FLECHA ESPECIAL */
  .arrow {
    background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
    animation: arrowPulse 1s ease-in-out infinite;
    box-shadow: 
      0 0 30px #ffd700,
      0 0 50px #ffd700,
      0 4px 8px rgba(0,0,0,0.4);
    border: 2px solid rgba(255,255,255,0.5);
  }

  .arrow::before {
    content: '';
    position: absolute;
    font-size: 0.8em;
    animation: arrowBounce 1s ease-in-out infinite;
  }

  .arrow.horizontal::before { content: '‚û°Ô∏è'; }
  .arrow.vertical::before { content: '‚¨ÜÔ∏è'; }

  @keyframes arrowPulse {
    0%, 100% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.1); filter: brightness(1.3); }
  }

  @keyframes arrowBounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-3px); }
  }

  /* RAYOS CONECTORES */
  .lightning {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    stroke: currentColor;
    stroke-width: 3;
    fill: none;
    filter: drop-shadow(0 0 10px currentColor);
    animation: lightningStrike 0.5s ease-out forwards;
  }

  @keyframes lightningStrike {
    0% { 
      opacity: 0; 
      stroke-width: 1;
      filter: drop-shadow(0 0 5px currentColor);
    }
    50% { 
      opacity: 1; 
      stroke-width: 4;
      filter: drop-shadow(0 0 20px currentColor);
    }
    100% { 
      opacity: 0; 
      stroke-width: 1;
      filter: drop-shadow(0 0 30px currentColor);
    }
  }

  /* ESQUIRLAS PARA MEGA EXPLOSI√ìN */
  .shard {
    position: fixed;
    width: 12px;
    height: 12px;
    pointer-events: none;
    z-index: 9999;
    animation: shardFly 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
  }

  @keyframes shardFly {
    0% {
      transform: translate(0, 0) scale(1) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translate(var(--dx), var(--dy)) scale(0) rotate(720deg);
      opacity: 0;
    }
  }

  /* ONDA EXPANSIVA MEJORADA */
  .mega-shockwave {
    position: fixed;
    left: 50%;
    top: 50%;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9998;
    background: radial-gradient(circle, transparent 30%, rgba(255,255,255,0.8) 35%, transparent 40%, rgba(255,255,255,0.6) 45%, transparent 50%);
    animation: megaShockwave 1s ease-out forwards;
  }

  @keyframes megaShockwave {
    0% {
      transform: translate(-50%, -50%) scale(0);
      opacity: 1;
    }
    100% {
      transform: translate(-50%, -50%) scale(100);
      opacity: 0;
    }
  }

  /* FLASH DE PANTALLA √âPICO */
  .mega-flash {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 9997;
    background: radial-gradient(ellipse at center, white, transparent 60%);
    animation: megaFlash 0.8s ease-out forwards;
  }

  @keyframes megaFlash {
    0% { opacity: 0; }
    20% { opacity: 1; }
    100% { opacity: 0; }
  }

  /* Animaci√≥n de ca√≠da */
  .falling {
    animation: fall var(--fall-duration, 0.3s) cubic-bezier(0.4, 0, 0.2, 1) both;
    animation-delay: var(--fall-delay, 0s);
  }

  @keyframes fall {
    from {
      transform: translateY(calc(var(--fall-distance, -50px) * -1));
      opacity: 0.5;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  /* Nueva ficha */
  .new-tile {
    animation: dropNew 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) both;
    animation-delay: var(--new-delay, 0s);
  }

  @keyframes dropNew {
    from {
      transform: translateY(-150%) scale(0.5) rotate(180deg);
      opacity: 0;
    }
    to {
      transform: translateY(0) scale(1) rotate(0deg);
      opacity: 1;
    }
  }

  /* Explosi√≥n */
  .exploding {
    animation: explode 0.3s ease-out forwards;
  }

  @keyframes explode {
    to {
      transform: scale(0);
      opacity: 0;
    }
  }

  /* Eliminaci√≥n de l√≠nea */
  .line-clear {
    animation: lineClear 0.5s ease-out forwards;
  }

  @keyframes lineClear {
    0% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.2); filter: brightness(2); }
    100% { transform: scale(0) rotate(180deg); opacity: 0; }
  }

  /* Toast */
  .toast {
    position: fixed;
    left: 50%;
    top: var(--safe-top);
    transform: translateX(-50%);
    background: rgba(255,255,255,0.95);
    color: #1a1a1a;
    padding: 8px 16px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 13px;
    z-index: 9999;
    animation: toastSlide 1.5s ease forwards;
  }

  @keyframes toastSlide {
    0% { transform: translateX(-50%) translateY(-100px); opacity: 0; }
    20%, 80% { transform: translateX(-50%) translateY(20px); opacity: 1; }
    100% { transform: translateX(-50%) translateY(-100px); opacity: 0; }
  }

  /* Modal */
  .modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    padding: 20px;
  }

  .modal-card {
    background: white;
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    color: #1a1a1a;
    max-width: 90%;
    animation: modalPop 0.3s ease;
  }

  @keyframes modalPop {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 {
    margin: 0 0 12px 0;
    font-size: 24px;
    color: #764ba2;
  }

  .modal .emoji {
    font-size: 48px;
    margin-bottom: 12px;
    animation: celebrateEmoji 1s ease-in-out infinite;
  }

  @keyframes celebrateEmoji {
    0%, 100% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.1) rotate(-10deg); }
    75% { transform: scale(1.1) rotate(10deg); }
  }

  .modal button {
    margin-top: 12px;
    padding: 10px 20px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
  }

  /* Footer */
  footer {
    text-align: center;
    font-size: 11px;
    padding: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    margin-top: 8px;
  }

  .lives-counter {
    font-weight: 700;
    color: #ff4d4f;
    font-size: 13px;
    margin-bottom: 4px;
  }

  .timer-info {
    color: #ffd93d;
    font-weight: 600;
    font-size: 12px;
  }

  .hint {
    color: #4ade80;
    font-weight: 600;
  }

  /* Part√≠cula */
  .particle {
    position: fixed;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9998;
    animation: particle 0.6s ease-out forwards;
  }

  @keyframes particle {
    to {
      transform: translate(var(--dx), var(--dy)) scale(0);
      opacity: 0;
    }
  }

  /* Rebote */
  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
  }

  /* Media queries para iPhone */
  @media screen and (max-width: 390px) {
    .board {
      max-width: calc(100vw - 32px);
    }
    
    .tile {
      font-size: min(6vw, 24px);
    }
  }
</style>
</head>
<body>
  <header>
    <div class="header-row">
      <div class="title">
        <span class="logo">üåà</span>
        <span>Explota-Color</span>
        <span class="level-indicator" id="levelIndicator">Nivel 1</span>
      </div>
      <div class="stats">
        <div class="pill">üéØ <span id="target">0</span></div>
        <div class="pill">‚≠ê <span id="score">0</span></div>
        <div class="pill">üëÜ <span id="moves">0</span></div>
      </div>
    </div>
    <div class="controls">
      <select id="themeSel">
        <option value="frutas">üçì Frutas</option>
        <option value="animales">üêµ Animales</option>
        <option value="caras">üòä Caras</option>
      </select>
      <button id="soundBtn">üîä</button>
      <button id="voiceBtn">üó£Ô∏è</button>
    </div>
  </header>

  <div class="board-wrap">
    <div id="board" class="board"></div>
  </div>

  <footer>
    <div class="lives-counter">‚ù§Ô∏è Vidas: <span id="livesLeft">5</span></div>
    <div class="timer-info" id="timerInfo" style="display: none;"></div>
    <div class="hint">‚ú® 2+ grupo ‚Ä¢ 4+ flecha ‚Ä¢ 5+ bal√≥n</div>
  </footer>

<script>
(function(){
  'use strict';
  
  // Configuraci√≥n
  const COLS = 6;
  const ROWS = 8;
  const MAX_LIVES = 5;
  const COOLDOWN_MINUTES = 25;

  // SISTEMA DE NIVELES PROGRESIVOS
  const GAME_LEVELS = [
    {
      level: 1,
      name: "Nivel 1",
      colors: 3, // Solo rojo, amarillo y azul
      target: 4000,
      moves: 35,
      description: "üåü ¬°Empezamos f√°cil!"
    },
    {
      level: 2,
      name: "Nivel 2",
      colors: 4, // A√±adimos verde
      target: 4000,
      moves: 30,
      description: "üåø ¬°Aparece el verde!"
    },
    {
      level: 3,
      name: "Nivel 3",
      colors: 5, // A√±adimos morado
      target: 4000,
      moves: 25,
      description: "üíú ¬°Todos los colores!"
    }
  ];

  const EMOJI_THEMES = {
    frutas: [
      { emoji: 'üçì', name: 'fresa' },     // Rojo
      { emoji: 'üçå', name: 'pl√°tano' },   // Amarillo  
      { emoji: 'ü´ê', name: 'ar√°ndano' },  // Azul
      { emoji: 'ü•ù', name: 'kiwi' },      // Verde
      { emoji: 'üçá', name: 'uvas' }       // Morado
    ],
    animales: [
      { emoji: 'ü¶Ä', name: 'cangrejo' },  // Rojo
      { emoji: 'üê•', name: 'pollito' },   // Amarillo
      { emoji: 'üê¨', name: 'delf√≠n' },    // Azul
      { emoji: 'üê∏', name: 'rana' },      // Verde
      { emoji: 'ü¶Ñ', name: 'unicornio' }  // Morado
    ],
    caras: [
      { emoji: 'üò°', name: 'enfadado' },  // Rojo
      { emoji: 'üòä', name: 'feliz' },     // Amarillo
      { emoji: 'üò¢', name: 'triste' },    // Azul
      { emoji: 'ü§¢', name: 'mareado' },   // Verde
      { emoji: 'üòà', name: 'diablillo' }  // Morado
    ]
  };

  // Sistema de sonido
  class SoundSystem {
    constructor() {
      this.enabled = true;
      this.audioCtx = null;
      this.init();
    }

    init() {
      try {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        console.warn('Audio no disponible');
      }
    }

    play(freq, duration = 0.2) {
      if (!this.enabled || !this.audioCtx) return;
      try {
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.start();
        osc.stop(this.audioCtx.currentTime + duration);
      } catch (e) {}
    }

    playPop() { this.play(600, 0.1); }
    playSuccess() { 
      [523, 659, 784].forEach((f, i) => {
        setTimeout(() => this.play(f, 0.15), i * 50);
      });
    }
    playSpecial() {
      [392, 523, 659, 784, 659, 523].forEach((f, i) => {
        setTimeout(() => this.play(f, 0.1), i * 40);
      });
    }
    playLevelUp() {
      [523, 587, 659, 784, 880, 1047].forEach((f, i) => {
        setTimeout(() => this.play(f, 0.2), i * 80);
      });
    }
    playError() { this.play(200, 0.3); }
  }

  // Sistema de voz
  class VoiceSystem {
    constructor() {
      this.enabled = false;
      this.synth = window.speechSynthesis;
    }

    speak(text, force = false) {
      if (!this.enabled && !force) return;
      if (!this.synth) return;
      
      try {
        this.synth.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'es-ES';
        utterance.pitch = 1.3;
        utterance.rate = 0.9;
        utterance.volume = 0.7;
        
        setTimeout(() => {
          this.synth.speak(utterance);
        }, 100);
      } catch (e) {}
    }

    toggle() {
      this.enabled = !this.enabled;
      if (this.enabled) {
        this.speak('¬°Voz activada!');
      }
      return this.enabled;
    }
  }

  // Estado del juego
  let state = {
    grid: [],
    score: 0,
    movesLeft: 35,
    target: 400,
    currentLevel: 1,
    theme: 'frutas',
    animating: false,
    livesLeft: MAX_LIVES,
    lockedUntil: null,
    totalScore: 0 // Puntuaci√≥n acumulada entre niveles
  };

  // Cargar estado guardado
  function loadState() {
    const saved = localStorage.getItem('gameState');
    if (saved) {
      const data = JSON.parse(saved);
      state.livesLeft = data.livesLeft || MAX_LIVES;
      state.lockedUntil = data.lockedUntil || null;
      state.currentLevel = data.currentLevel || 1;
      state.totalScore = data.totalScore || 0;
    }
  }

  function saveState() {
    localStorage.setItem('gameState', JSON.stringify({
      livesLeft: state.livesLeft,
      lockedUntil: state.lockedUntil,
      currentLevel: state.currentLevel,
      totalScore: state.totalScore
    }));
  }

  let currentTheme = EMOJI_THEMES.frutas;
  const soundSystem = new SoundSystem();
  const voiceSystem = new VoiceSystem();
  let timerInterval = null;

  // Elementos DOM
  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const movesEl = document.getElementById('moves');
  const targetEl = document.getElementById('target');
  const livesLeftEl = document.getElementById('livesLeft');
  const timerInfoEl = document.getElementById('timerInfo');
  const levelIndicatorEl = document.getElementById('levelIndicator');
  const themeSel = document.getElementById('themeSel');
  const soundBtn = document.getElementById('soundBtn');
  const voiceBtn = document.getElementById('voiceBtn');

  // Obtener configuraci√≥n del nivel actual
  function getCurrentLevelConfig() {
    const index = Math.min(state.currentLevel - 1, GAME_LEVELS.length - 1);
    return GAME_LEVELS[index];
  }

  // Renderizado
  function render(animateChanges = false) {
    boardEl.innerHTML = '';
    const fragment = document.createDocumentFragment();
    
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const cell = state.grid[y][x];
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.x = x;
        tile.dataset.y = y;
        
        if (!cell) {
          tile.style.visibility = 'hidden';
        } else {
          tile.classList.add(`c${cell.color}`);
          
          if (cell.kind === 'ball') {
            tile.classList.add('ball');
          } else if (cell.kind === 'arrow') {
            tile.classList.add('arrow', cell.direction);
          } else {
            tile.textContent = currentTheme[cell.color].emoji;
          }
          
          // Animaciones
          if (animateChanges && cell.fallFrom !== undefined) {
            const distance = (cell.fallFrom - y) * 50;
            tile.style.setProperty('--fall-distance', `${distance}px`);
            tile.style.setProperty('--fall-duration', `${0.3 + (cell.fallFrom - y) * 0.05}s`);
            tile.style.setProperty('--fall-delay', `${x * 0.02}s`);
            tile.classList.add('falling');
            delete cell.fallFrom;
          }
          
          if (animateChanges && cell.isNew) {
            tile.style.setProperty('--new-delay', `${(x * 0.03) + 0.1}s`);
            tile.classList.add('new-tile');
            delete cell.isNew;
          }
        }
        
        fragment.appendChild(tile);
      }
    }
    
    boardEl.appendChild(fragment);
  }

  // Dibujar rayos conectores
  function drawLightning(fromX, fromY, targets, color) {
    const fromTile = boardEl.querySelector(`[data-x="${fromX}"][data-y="${fromY}"]`);
    if (!fromTile) return;
    
    const fromRect = fromTile.getBoundingClientRect();
    const fromCenterX = fromRect.left + fromRect.width / 2;
    const fromCenterY = fromRect.top + fromRect.height / 2;
    
    const colors = ['#ff4d4f', '#f59e0b', '#3b82f6', '#22c55e', '#a855f7'];
    const strokeColor = colors[color];
    
    targets.forEach(([toX, toY]) => {
      const toTile = boardEl.querySelector(`[data-x="${toX}"][data-y="${toY}"]`);
     if (!toTile) return;
     
     const toRect = toTile.getBoundingClientRect();
     const toCenterX = toRect.left + toRect.width / 2;
     const toCenterY = toRect.top + toRect.height / 2;
     
     // Crear SVG para el rayo
     const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
     svg.classList.add('lightning');
     svg.style.position = 'fixed';
     svg.style.left = '0';
     svg.style.top = '0';
     svg.style.width = '100%';
     svg.style.height = '100%';
     svg.style.color = strokeColor;
     
     const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
     
     // Calcular puntos intermedios para zigzag
     const midX = (fromCenterX + toCenterX) / 2;
     const midY = (fromCenterY + toCenterY) / 2;
     const offset = 15;
     const zigX1 = midX + (Math.random() - 0.5) * offset;
     const zigY1 = midY + (Math.random() - 0.5) * offset;
     
     path.setAttribute('d', `M ${fromCenterX} ${fromCenterY} L ${zigX1} ${zigY1} L ${toCenterX} ${toCenterY}`);
     
     svg.appendChild(path);
     document.body.appendChild(svg);
     
     setTimeout(() => svg.remove(), 500);
   });
 }

 // NUEVA FUNCI√ìN: Mega explosi√≥n con esquirlas
 function createMegaExplosion() {
   // Crear onda expansiva
   const shockwave = document.createElement('div');
   shockwave.className = 'mega-shockwave';
   document.body.appendChild(shockwave);
   setTimeout(() => shockwave.remove(), 1000);
   
   // Crear flash √©pico
   const flash = document.createElement('div');
   flash.className = 'mega-flash';
   document.body.appendChild(flash);
   setTimeout(() => flash.remove(), 800);
   
   // Crear esquirlas por toda la pantalla
   const colors = ['#ff4d4f', '#f59e0b', '#3b82f6', '#22c55e', '#a855f7'];
   const boardRect = boardEl.getBoundingClientRect();
   const centerX = boardRect.left + boardRect.width / 2;
   const centerY = boardRect.top + boardRect.height / 2;
   
   // Crear muchas esquirlas
   for (let i = 0; i < 50; i++) {
     setTimeout(() => {
       const shard = document.createElement('div');
       shard.className = 'shard';
       shard.style.left = centerX + 'px';
       shard.style.top = centerY + 'px';
       
       // Color aleatorio
       const color = colors[Math.floor(Math.random() * colors.length)];
       shard.style.background = `linear-gradient(45deg, ${color}, white)`;
       shard.style.boxShadow = `0 0 20px ${color}`;
       
       // Direcci√≥n aleatoria en 360 grados
       const angle = (Math.PI * 2 * i) / 50 + (Math.random() - 0.5) * 0.5;
       const distance = 200 + Math.random() * 300;
       const dx = Math.cos(angle) * distance;
       const dy = Math.sin(angle) * distance;
       
       shard.style.setProperty('--dx', dx + 'px');
       shard.style.setProperty('--dy', dy + 'px');
       
       document.body.appendChild(shard);
       setTimeout(() => shard.remove(), 1200);
     }, i * 10);
   }
   
   // Vibraci√≥n √©pica
   if (navigator.vibrate) {
     navigator.vibrate([100, 50, 100, 50, 200]);
   }
 }

 // Click en ficha
 boardEl.addEventListener('click', (e) => {
   if (state.animating) return;
   if (checkLocked()) return;
   
   const tile = e.target.closest('.tile');
   if (!tile) return;
   
   const x = parseInt(tile.dataset.x);
   const y = parseInt(tile.dataset.y);
   const cell = state.grid[y]?.[x];
   
   if (!cell) return;
   
   if (cell.kind === 'ball') {
     handleBallClick(x, y, cell.color);
   } else if (cell.kind === 'arrow') {
     handleArrowClick(x, y, cell.direction);
   } else {
     handleNormalClick(x, y, cell.color);
   }
 });

 // Manejar click normal
 function handleNormalClick(x, y, color) {
   const group = findGroup(x, y, color);
   
   if (group.length < 2) {
     const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
     if (tile) {
       tile.style.animation = 'bounce 0.3s';
       setTimeout(() => tile.style.animation = '', 300);
     }
     soundSystem.playError();
     return;
   }
   
   state.animating = true;
   spendMove();
   
   // GRUPO DE 5+: Crear bal√≥n
   if (group.length >= 5) {
     animateExplosion(group.filter(([gx, gy]) => !(gx === x && gy === y)));
     
     setTimeout(() => {
       for (const [gx, gy] of group) {
         if (!(gx === x && gy === y)) {
           spawnParticles(gx, gy, color);
           state.grid[gy][gx] = null;
         }
       }
       
       state.grid[y][x] = { kind: 'ball', color: color };
       
       soundSystem.playSpecial();
       voiceSystem.speak('¬°Bal√≥n m√°gico!');
       showToast('‚öΩ ¬°Bal√≥n m√°gico!');
       
       applyGravity();
       fillEmpty();
       render(true);
       
       setTimeout(() => {
         state.animating = false;
         checkGameState();
       }, 600);
     }, 300);
     
     addScore(100 + group.length * 10);
     return;
   }
   
   // GRUPO DE 4: Crear flecha
   if (group.length === 4) {
     animateExplosion(group.filter(([gx, gy]) => !(gx === x && gy === y)));
     
     setTimeout(() => {
       for (const [gx, gy] of group) {
         if (!(gx === x && gy === y)) {
           spawnParticles(gx, gy, color);
           state.grid[gy][gx] = null;
         }
       }
       
       const direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
       state.grid[y][x] = { kind: 'arrow', direction: direction, color: color };
       
       soundSystem.playSuccess();
       voiceSystem.speak('¬°Flecha especial!');
       showToast(direction === 'horizontal' ? '‚û°Ô∏è ¬°Flecha horizontal!' : '‚¨ÜÔ∏è ¬°Flecha vertical!');
       
       applyGravity();
       fillEmpty();
       render(true);
       
       setTimeout(() => {
         state.animating = false;
         checkGameState();
       }, 600);
     }, 300);
     
     addScore(80);
     return;
   }
   
   // Grupo normal (2-3)
   animateExplosion(group);
   
   setTimeout(() => {
     for (const [gx, gy] of group) {
       spawnParticles(gx, gy, color);
       state.grid[gy][gx] = null;
     }
     
     soundSystem.playPop();
     
     if (group.length >= 3) {
       voiceSystem.speak('¬°Bien hecho!');
     }
     
     applyGravity();
     fillEmpty();
     render(true);
     
     setTimeout(() => {
       state.animating = false;
       checkGameState();
     }, 600);
   }, 300);
   
   addScore(group.length * 15);
 }

 // Manejar click en flecha
 function handleArrowClick(x, y, direction) {
   state.animating = true;
   spendMove();
   
   const targets = [];
   
   if (direction === 'horizontal') {
     for (let px = 0; px < COLS; px++) {
       if (state.grid[y][px] && state.grid[y][px].kind === 'normal') {
         targets.push([px, y]);
       }
     }
     voiceSystem.speak('¬°Explosi√≥n horizontal!');
     showToast('‚û°Ô∏è ¬°Fila eliminada!');
   } else {
     for (let py = 0; py < ROWS; py++) {
       if (state.grid[py][x] && state.grid[py][x].kind === 'normal') {
         targets.push([x, py]);
       }
     }
     voiceSystem.speak('¬°Explosi√≥n vertical!');
     showToast('‚¨ÜÔ∏è ¬°Columna eliminada!');
   }
   
   targets.forEach(([tx, ty]) => {
     const tile = boardEl.querySelector(`[data-x="${tx}"][data-y="${ty}"]`);
     if (tile) {
       tile.classList.add('line-clear');
     }
   });
   
   setTimeout(() => {
     state.grid[y][x] = null;
     
     for (const [tx, ty] of targets) {
       if (state.grid[ty] && state.grid[ty][tx]) {
         spawnParticles(tx, ty, state.grid[ty][tx].color);
         state.grid[ty][tx] = null;
       }
     }
     
     soundSystem.playSpecial();
     applyGravity();
     fillEmpty();
     render(true);
     
     setTimeout(() => {
       state.animating = false;
       checkGameState();
     }, 600);
   }, 500);
   
   addScore(targets.length * 30);
 }

 // Manejar click en bal√≥n CON MEGA EXPLOSI√ìN
 function handleBallClick(x, y, color) {
   state.animating = true;
   spendMove();
   
   const ballCluster = findBallCluster(x, y);
   
   if (ballCluster.length >= 2) {
     // MEGA EXPLOSI√ìN √âPICA
     voiceSystem.speak('¬°Mega explosi√≥n!');
     showToast('üí• ¬°¬°¬°MEGA EXPLOSI√ìN!!! üí•');
     
     // Crear efectos especiales
     createMegaExplosion();
     
     setTimeout(() => {
       // Eliminar todo
       for (let py = 0; py < ROWS; py++) {
         for (let px = 0; px < COLS; px++) {
           if (state.grid[py][px]) {
             if (state.grid[py][px].kind === 'normal') {
               spawnParticles(px, py, state.grid[py][px].color);
               state.grid[py][px] = null;
             } else if (ballCluster.some(([bx, by]) => bx === px && by === py)) {
               state.grid[py][px] = null;
             }
           }
         }
       }
       
       soundSystem.playSpecial();
       applyGravity();
       fillEmpty();
       render(true);
       
       setTimeout(() => {
         state.animating = false;
         checkGameState();
       }, 600);
     }, 600);
     
     addScore(800);
   } else {
     // Eliminar color con rayos
     const targets = [];
     for (let py = 0; py < ROWS; py++) {
       for (let px = 0; px < COLS; px++) {
         const cell = state.grid[py][px];
         if (cell && cell.kind === 'normal' && cell.color === color) {
           targets.push([px, py]);
         }
       }
     }
     
     drawLightning(x, y, targets, color);
     
     setTimeout(() => {
       animateExplosion(targets);
       
       setTimeout(() => {
         state.grid[y][x] = null;
         for (const [tx, ty] of targets) {
           spawnParticles(tx, ty, color);
           state.grid[ty][tx] = null;
         }
         
         soundSystem.playSpecial();
         voiceSystem.speak('¬°Explosi√≥n de color!');
         showToast(`‚öΩ ¬°${currentTheme[color].emoji} eliminados!`);
         
         applyGravity();
         fillEmpty();
         render(true);
         
         setTimeout(() => {
           state.animating = false;
           checkGameState();
         }, 600);
       }, 300);
     }, 200);
     
     addScore(targets.length * 25);
   }
 }

 // Gravedad
 function applyGravity() {
   for (let x = 0; x < COLS; x++) {
     const column = [];
     
     for (let y = 0; y < ROWS; y++) {
       if (state.grid[y][x]) {
         column.push({
           cell: state.grid[y][x],
           originalY: y
         });
       }
     }
     
     for (let y = 0; y < ROWS; y++) {
       state.grid[y][x] = null;
     }
     
     let writePos = ROWS - 1;
     for (let i = column.length - 1; i >= 0; i--) {
       const item = column[i];
       state.grid[writePos][x] = item.cell;
       
       if (writePos > item.originalY) {
         state.grid[writePos][x].fallFrom = item.originalY;
       }
       
       writePos--;
     }
   }
 }

 // Rellenar vac√≠os con colores seg√∫n el nivel
 function fillEmpty() {
   const levelConfig = getCurrentLevelConfig();
   const maxColors = levelConfig.colors;
   
   for (let y = 0; y < ROWS; y++) {
     for (let x = 0; x < COLS; x++) {
       if (!state.grid[y][x]) {
         state.grid[y][x] = {
           kind: 'normal',
           color: Math.floor(Math.random() * maxColors),
           isNew: true
         };
       }
     }
   }
 }

 // Buscar grupo
 function findGroup(startX, startY, color) {
   const visited = new Set();
   const stack = [[startX, startY]];
   const group = [];
   
   while (stack.length > 0) {
     const [x, y] = stack.pop();
     const key = `${x},${y}`;
     
     if (visited.has(key)) continue;
     visited.add(key);
     
     const cell = state.grid[y]?.[x];
     if (!cell || cell.kind !== 'normal' || cell.color !== color) continue;
     
     group.push([x, y]);
     
     if (x > 0) stack.push([x - 1, y]);
     if (x < COLS - 1) stack.push([x + 1, y]);
     if (y > 0) stack.push([x, y - 1]);
     if (y < ROWS - 1) stack.push([x, y + 1]);
   }
   
   return group;
 }

 // Buscar cluster de balones
 function findBallCluster(startX, startY) {
   const visited = new Set();
   const stack = [[startX, startY]];
   const cluster = [];
   
   while (stack.length > 0) {
     const [x, y] = stack.pop();
     const key = `${x},${y}`;
     
     if (visited.has(key)) continue;
     visited.add(key);
     
     const cell = state.grid[y]?.[x];
     if (!cell || cell.kind !== 'ball') continue;
     
     cluster.push([x, y]);
     
     if (x > 0) stack.push([x - 1, y]);
     if (x < COLS - 1) stack.push([x + 1, y]);
     if (y > 0) stack.push([x, y - 1]);
     if (y < ROWS - 1) stack.push([x, y + 1]);
   }
   
   return cluster;
 }

 // Animaciones
 function animateExplosion(cells) {
   for (const [x, y] of cells) {
     const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
     if (tile) {
       tile.classList.add('exploding');
     }
   }
 }

 // Part√≠culas
 function spawnParticles(x, y, color) {
   const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
   if (!tile) return;
   
   const rect = tile.getBoundingClientRect();
   const colors = ['#ff4d4f', '#f59e0b', '#3b82f6', '#22c55e', '#a855f7'];
   
   for (let i = 0; i < 6; i++) {
     const particle = document.createElement('div');
     particle.className = 'particle';
     particle.style.left = rect.left + rect.width / 2 + 'px';
     particle.style.top = rect.top + rect.height / 2 + 'px';
     particle.style.background = colors[color];
     
     const angle = (Math.PI * 2 * i) / 6;
     const distance = 40 + Math.random() * 30;
     particle.style.setProperty('--dx', Math.cos(angle) * distance + 'px');
     particle.style.setProperty('--dy', Math.sin(angle) * distance + 'px');
     
     document.body.appendChild(particle);
     setTimeout(() => particle.remove(), 600);
   }
 }

 // UI
 function showToast(message) {
   const existing = document.querySelector('.toast');
   if (existing) existing.remove();
   
   const toast = document.createElement('div');
   toast.className = 'toast';
   toast.textContent = message;
   document.body.appendChild(toast);
   setTimeout(() => toast.remove(), 4000);
 }

 function addScore(points) {
   state.score += points;
   updateUI();
   showToast(`+${points} ‚≠ê`);
 }

 function spendMove() {
   if (state.movesLeft > 0) {
     state.movesLeft--;
     updateUI();
   }
 }

 function updateUI() {
   scoreEl.textContent = state.score;
   movesEl.textContent = state.movesLeft;
   targetEl.textContent = state.target;
   livesLeftEl.textContent = state.livesLeft;
   levelIndicatorEl.textContent = `Nivel ${state.currentLevel}`;
 }

 // Sistema de vidas
 function checkLocked() {
   if (state.lockedUntil) {
     const now = Date.now();
     if (now < state.lockedUntil) {
       showLockedModal();
       return true;
     } else {
       state.lockedUntil = null;
       state.livesLeft = MAX_LIVES;
       saveState();
       timerInfoEl.style.display = 'none';
       return false;
     }
   }
   return false;
 }

 function consumeLife() {
   state.livesLeft--;
   saveState();
   updateUI();
   
   if (state.livesLeft <= 0) {
     state.lockedUntil = Date.now() + (COOLDOWN_MINUTES * 60 * 1000);
     saveState();
     showLockedModal();
     startTimer();
   }
 }

 function showLockedModal() {
   voiceSystem.speak('¬°No hay m√°s vidas! Espera un poquito', true);
   
   const timeLeft = Math.ceil((state.lockedUntil - Date.now()) / 1000 / 60);
   
   const modal = document.createElement('div');
   modal.className = 'modal';
   modal.innerHTML = `
     <div class="modal-card">
       <div class="emoji">‚è∞</div>
       <h2>¬°Sin vidas!</h2>
       <p>Tienes que esperar ${timeLeft} minutos</p>
       <p>¬°Ve a jugar con tus juguetes!</p>
       <button onclick="this.closest('.modal').remove()">OK</button>
     </div>
   `;
   document.body.appendChild(modal);
 }

 function startTimer() {
   if (timerInterval) clearInterval(timerInterval);
   
   timerInterval = setInterval(() => {
     if (!state.lockedUntil) {
       clearInterval(timerInterval);
       timerInfoEl.style.display = 'none';
       return;
     }
     
     const now = Date.now();
     if (now >= state.lockedUntil) {
       state.lockedUntil = null;
       state.livesLeft = MAX_LIVES;
       saveState();
       updateUI();
       timerInfoEl.style.display = 'none';
       clearInterval(timerInterval);
       showToast('¬°Vidas restauradas! üéâ');
       voiceSystem.speak('¬°Ya puedes jugar otra vez!', true);
     } else {
       const seconds = Math.ceil((state.lockedUntil - now) / 1000);
       const minutes = Math.floor(seconds / 60);
       const secs = seconds % 60;
       timerInfoEl.textContent = `‚è∞ Espera: ${minutes}:${secs.toString().padStart(2, '0')}`;
       timerInfoEl.style.display = 'block';
     }
   }, 1000);
 }

 // Verificar estado del juego
 function checkGameState() {
   if (state.score >= state.target) {
     levelComplete();
   } else if (state.movesLeft === 0) {
     showGameOver();
   }
 }

 // NUEVO: Completar nivel
 function levelComplete() {
   soundSystem.playLevelUp();
   state.totalScore += state.score;
   
   if (state.currentLevel < GAME_LEVELS.length) {
     // Pasar al siguiente nivel
     state.currentLevel++;
     saveState();
     
     const nextLevel = getCurrentLevelConfig();
     voiceSystem.speak(`¬°Nivel ${state.currentLevel}! ${nextLevel.description}`, true);
     
     const modal = document.createElement('div');
     modal.className = 'modal';
     modal.innerHTML = `
       <div class="modal-card">
         <div class="emoji">üéâ</div>
         <h2>¬°Nivel Completado!</h2>
         <p>¬°Conseguiste ${state.score} puntos!</p>
         <p><strong>${nextLevel.description}</strong></p>
         <p>Siguiente: ${nextLevel.name}</p>
         <button onclick="window.nextLevel()">üéÆ Siguiente Nivel</button>
       </div>
     `;
     document.body.appendChild(modal);
   } else {
     // Juego completado
     voiceSystem.speak('¬°Felicidades! ¬°Completaste todos los niveles!', true);
     
     const modal = document.createElement('div');
     modal.className = 'modal';
     modal.innerHTML = `
       <div class="modal-card">
         <div class="emoji">üèÜ</div>
         <h2>¬°JUEGO COMPLETADO!</h2>
         <p>¬°Eres un campe√≥n!</p>
         <p>Puntuaci√≥n total: ${state.totalScore} ‚≠ê</p>
         <button onclick="window.resetGame()">üéÆ Jugar de nuevo</button>
       </div>
     `;
     document.body.appendChild(modal);
   }
 }

 function showGameOver() {
   voiceSystem.speak('¬°Se acab√≥! Una vida menos');
   
   consumeLife();
   
   const modal = document.createElement('div');
   modal.className = 'modal';
   modal.innerHTML = `
     <div class="modal-card">
       <div class="emoji">üò¢</div>
       <h2>¬°Se acab√≥!</h2>
       <p>Conseguiste ${state.score} puntos</p>
       <p>Te faltan ${state.target - state.score} puntos</p>
       <p>‚ù§Ô∏è Vidas restantes: ${state.livesLeft}</p>
       ${state.livesLeft > 0 ? 
         '<button onclick="window.startNewGame()">üéÆ Reintentar</button>' :
         '<button onclick="this.closest(\'.modal\').remove()">OK</button>'
       }
     </div>
   `;
   document.body.appendChild(modal);
 }

 // Funciones globales
 window.nextLevel = function() {
   const modal = document.querySelector('.modal');
   if (modal) modal.remove();
   
   init();
   showToast(`¬°Nivel ${state.currentLevel}! üöÄ`);
 };

 window.resetGame = function() {
   const modal = document.querySelector('.modal');
   if (modal) modal.remove();
   
   state.currentLevel = 1;
   state.totalScore = 0;
   saveState();
   
   init();
   showToast('¬°Nueva aventura! üéÆ');
 };

 window.startNewGame = function() {
   const modal = document.querySelector('.modal');
   if (modal) modal.remove();
   
   if (checkLocked()) return;
   
   init();
   showToast('¬°Intentando de nuevo! üéÆ');
 };

 // Inicializaci√≥n
 function init() {
   const levelConfig = getCurrentLevelConfig();
   
   state.theme = themeSel.value;
   currentTheme = EMOJI_THEMES[state.theme];
   
   state.target = levelConfig.target;
   state.movesLeft = levelConfig.moves;
   state.score = 0;
   state.animating = false;
   
   generateBoard();
   render(false);
   updateUI();
 }

 // Generaci√≥n de tablero con colores seg√∫n nivel
 function generateBoard() {
   const levelConfig = getCurrentLevelConfig();
   const maxColors = levelConfig.colors;
   
   state.grid = [];
   
   for (let y = 0; y < ROWS; y++) {
     state.grid[y] = [];
     for (let x = 0; x < COLS; x++) {
       let color;
       const forbidden = new Set();
       
       if (x >= 2 && 
           state.grid[y][x-1].color === state.grid[y][x-2].color) {
         forbidden.add(state.grid[y][x-1].color);
       }
       
       if (y >= 2 && 
           state.grid[y-1] && state.grid[y-1][x] &&
           state.grid[y-2] && state.grid[y-2][x] &&
           state.grid[y-1][x].color === state.grid[y-2][x].color) {
         forbidden.add(state.grid[y-1][x].color);
       }
       
       const availableColors = [];
       for (let c = 0; c < maxColors; c++) {
         if (!forbidden.has(c)) availableColors.push(c);
       }
       
       color = availableColors[Math.floor(Math.random() * availableColors.length)];
       
       state.grid[y][x] = {
         kind: 'normal',
         color: color
       };
     }
   }
   
   ensurePlayableMoves();
 }

 function ensurePlayableMoves() {
   let hasMove = false;
   
   for (let y = 0; y < ROWS && !hasMove; y++) {
     for (let x = 0; x < COLS && !hasMove; x++) {
       const group = findGroup(x, y, state.grid[y][x].color);
       if (group.length >= 2) {
         hasMove = true;
       }
     }
   }
   
   if (!hasMove) {
     const x = Math.floor(Math.random() * (COLS - 1));
     const y = Math.floor(Math.random() * ROWS);
     const color = state.grid[y][x].color;
     state.grid[y][x + 1].color = color;
   }
 }

 // Event listeners
 themeSel.addEventListener('change', () => {
   currentTheme = EMOJI_THEMES[themeSel.value];
   render(false);
   showToast(`Tema: ${themeSel.options[themeSel.selectedIndex].text}`);
 });

 soundBtn.addEventListener('click', () => {
   soundSystem.enabled = !soundSystem.enabled;
   soundBtn.textContent = soundSystem.enabled ? 'üîä' : 'üîá';
   showToast(soundSystem.enabled ? 'Sonido ON' : 'Sonido OFF');
 });

 voiceBtn.addEventListener('click', () => {
   const enabled = voiceSystem.toggle();
   voiceBtn.textContent = enabled ? 'üó£Ô∏è' : 'üîï';
   showToast(enabled ? 'Voz ON' : 'Voz OFF');
 });

 // Iniciar
 loadState();
 if (state.lockedUntil && Date.now() < state.lockedUntil) {
   startTimer();
 }
 checkLocked();
 init();
 
 // Mensaje de bienvenida seg√∫n el nivel
 const levelConfig = getCurrentLevelConfig();
 showToast(`${levelConfig.description}`);

})();
</script>
</body>
</html>
