<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Explota-Color üåà</title>
<style>
  :root {
    --bg: #0f172a;
    --gap: 6px;
    --radius: 14px;

    /* Colores vibrantes */
    --c0: #ff4d4f;
    --c1: #3b82f6;
    --c2: #22c55e;
    --c3: #f59e0b;
    --c4: #a855f7;

    --text: #e5e7eb;
    --muted: #9ca3af;
    
    /* Safe areas para iPhone */
    --safe-top: max(10px, env(safe-area-inset-top));
    --safe-bottom: max(10px, env(safe-area-inset-bottom));
    --safe-left: max(10px, env(safe-area-inset-left));
    --safe-right: max(10px, env(safe-area-inset-right));
  }

  * { 
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    margin: 0;
    padding: 0;
  }
  
  html { 
    height: 100%; 
    height: -webkit-fill-available;
  }
  
  body {
    min-height: 100vh;
    min-height: -webkit-fill-available;
    overflow: hidden;
    background: linear-gradient(180deg, #667eea, #764ba2);
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    padding: var(--safe-top) var(--safe-left) var(--safe-bottom) var(--safe-right);
  }

  /* Header compacto para iPhone */
  header {
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 8px;
    margin-bottom: 8px;
  }

  .header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .title {
    font-weight: 700;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .title .logo {
    font-size: 18px;
  }

  .stats {
    display: flex;
    gap: 6px;
    font-size: 11px;
    font-weight: 600;
  }

  .pill {
    background: rgba(255,255,255,0.15);
    padding: 3px 8px;
    border-radius: 999px;
    display: flex;
    align-items: center;
    gap: 3px;
  }

  .controls {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }

  .controls select,
  .controls button {
    flex: 1;
    min-width: 0;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: #fff;
    font-weight: 600;
    font-size: 11px;
  }

  button:active {
    transform: scale(0.95);
  }

  /* Tablero responsive */
  .board-wrap {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 8px;
  }

  .board {
    --cols: 6;
    --rows: 8;
    width: 100%;
    max-width: 380px;
    aspect-ratio: 6/8;
    display: grid;
    grid-template-columns: repeat(var(--cols), 1fr);
    grid-template-rows: repeat(var(--rows), 1fr);
    gap: var(--gap);
    padding: 10px;
    border-radius: 16px;
    background: rgba(0,0,0,0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  /* Fichas responsivas */
  .tile {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: min(5vw, 28px);
    border-radius: var(--radius);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    cursor: pointer;
    transition: transform 0.15s;
    position: relative;
  }

  .tile:active {
    transform: scale(0.9);
  }

  /* Colores correctos */
  .c0 { background: linear-gradient(135deg, #ff6b6b, #ff4d4f); }
  .c1 { background: linear-gradient(135deg, #4ecdc4, #3b82f6); }
  .c2 { background: linear-gradient(135deg, #4ade80, #22c55e); }
  .c3 { background: linear-gradient(135deg, #ffd93d, #f59e0b); }
  .c4 { background: linear-gradient(135deg, #c77dff, #a855f7); }

  /* PELOTA ESPECIAL MEJORADA - Como bal√≥n de f√∫tbol girando */
  .ball {
    background: conic-gradient(
      from 0deg,
      currentColor 0deg 30deg,
      white 30deg 60deg,
      currentColor 60deg 90deg,
      white 90deg 120deg,
      currentColor 120deg 150deg,
      white 150deg 180deg,
      currentColor 180deg 210deg,
      white 210deg 240deg,
      currentColor 240deg 270deg,
      white 270deg 300deg,
      currentColor 300deg 330deg,
      white 330deg 360deg
    ) !important;
    animation: rotateBall 2s linear infinite;
    box-shadow: 
      0 0 30px currentColor,
      0 0 50px currentColor,
      inset 0 0 20px rgba(0,0,0,0.3),
      0 4px 8px rgba(0,0,0,0.4);
    border: 2px solid rgba(255,255,255,0.3);
  }

  .ball.c0 { color: #ff4d4f; }
  .ball.c1 { color: #3b82f6; }
  .ball.c2 { color: #22c55e; }
  .ball.c3 { color: #f59e0b; }
  .ball.c4 { color: #a855f7; }

  .ball::before {
    content: '‚öΩ';
    font-size: 0.7em;
    position: absolute;
    animation: pulse 1s ease-in-out infinite;
  }

  @keyframes rotateBall {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.2); opacity: 1; }
  }

  /* FLECHA ESPECIAL - Para eliminar fila/columna */
  .arrow {
    background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
    animation: arrowPulse 1s ease-in-out infinite;
    box-shadow: 
      0 0 30px #ffd700,
      0 0 50px #ffd700,
      0 4px 8px rgba(0,0,0,0.4);
    border: 2px solid rgba(255,255,255,0.5);
  }

  .arrow::before {
    content: '';
    position: absolute;
    font-size: 0.8em;
    animation: arrowBounce 1s ease-in-out infinite;
  }

  .arrow.horizontal::before { content: '‚û°Ô∏è'; }
  .arrow.vertical::before { content: '‚¨ÜÔ∏è'; }

  @keyframes arrowPulse {
    0%, 100% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.1); filter: brightness(1.3); }
  }

  @keyframes arrowBounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-3px); }
  }

  /* RAYOS CONECTORES */
  .lightning {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    stroke: currentColor;
    stroke-width: 3;
    fill: none;
    filter: drop-shadow(0 0 10px currentColor);
    animation: lightningStrike 0.5s ease-out forwards;
  }

  @keyframes lightningStrike {
    0% { 
      opacity: 0; 
      stroke-width: 1;
      filter: drop-shadow(0 0 5px currentColor);
    }
    50% { 
      opacity: 1; 
      stroke-width: 4;
      filter: drop-shadow(0 0 20px currentColor);
    }
    100% { 
      opacity: 0; 
      stroke-width: 1;
      filter: drop-shadow(0 0 30px currentColor);
    }
  }

  /* Animaci√≥n de ca√≠da */
  .falling {
    animation: fall var(--fall-duration, 0.3s) cubic-bezier(0.4, 0, 0.2, 1) both;
    animation-delay: var(--fall-delay, 0s);
  }

  @keyframes fall {
    from {
      transform: translateY(calc(var(--fall-distance, -50px) * -1));
      opacity: 0.5;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  /* Nueva ficha */
  .new-tile {
    animation: dropNew 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) both;
    animation-delay: var(--new-delay, 0s);
  }

  @keyframes dropNew {
    from {
      transform: translateY(-150%) scale(0.5) rotate(180deg);
      opacity: 0;
    }
    to {
      transform: translateY(0) scale(1) rotate(0deg);
      opacity: 1;
    }
  }

  /* Explosi√≥n */
  .exploding {
    animation: explode 0.3s ease-out forwards;
  }

  @keyframes explode {
    to {
      transform: scale(0);
      opacity: 0;
    }
  }

  /* Rebote */
  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
  }

  /* Eliminaci√≥n de l√≠nea */
  .line-clear {
    animation: lineClear 0.5s ease-out forwards;
  }

  @keyframes lineClear {
    0% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.2); filter: brightness(2); }
    100% { transform: scale(0) rotate(180deg); opacity: 0; }
  }

  /* Toast */
  .toast {
    position: fixed;
    left: 50%;
    top: var(--safe-top);
    transform: translateX(-50%);
    background: rgba(255,255,255,0.95);
    color: #1a1a1a;
    padding: 8px 16px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 13px;
    z-index: 9999;
    animation: toastSlide 1.5s ease forwards;
  }

  @keyframes toastSlide {
    0% { transform: translateX(-50%) translateY(-100px); opacity: 0; }
    20%, 80% { transform: translateX(-50%) translateY(20px); opacity: 1; }
    100% { transform: translateX(-50%) translateY(-100px); opacity: 0; }
  }

  /* Modal */
  .modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    padding: 20px;
  }

  .modal-card {
    background: white;
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    color: #1a1a1a;
    max-width: 90%;
    animation: modalPop 0.3s ease;
  }

  @keyframes modalPop {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 {
    margin: 0 0 12px 0;
    font-size: 24px;
    color: #764ba2;
  }

  .modal .emoji {
    font-size: 48px;
    margin-bottom: 12px;
  }

  .modal button {
    margin-top: 12px;
    padding: 10px 20px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
  }

  /* Footer con contador de vidas */
  footer {
    text-align: center;
    font-size: 11px;
    padding: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    margin-top: 8px;
  }

  .lives-counter {
    font-weight: 700;
    color: #ff4d4f;
    font-size: 13px;
    margin-bottom: 4px;
  }

  .timer-info {
    color: #ffd93d;
    font-weight: 600;
    font-size: 12px;
  }

  .hint {
    color: #4ade80;
    font-weight: 600;
  }

  /* Part√≠cula */
  .particle {
    position: fixed;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9998;
    animation: particle 0.6s ease-out forwards;
  }

  @keyframes particle {
    to {
      transform: translate(var(--dx), var(--dy)) scale(0);
      opacity: 0;
    }
  }

  /* Media queries para iPhone */
  @media screen and (max-width: 390px) {
    .board {
      max-width: calc(100vw - 32px);
    }
    
    .tile {
      font-size: min(6vw, 24px);
    }
  }

  @media screen and (max-height: 700px) {
    header { padding: 6px; }
    .header-row { margin-bottom: 4px; }
    .controls { gap: 3px; }
    .board { gap: 4px; padding: 8px; }
  }
</style>
</head>
<body>
  <header>
    <div class="header-row">
      <div class="title">
        <span class="logo">üåà</span>
        <span>Explota-Color</span>
      </div>
      <div class="stats">
        <div class="pill">üéØ <span id="target">0</span></div>
        <div class="pill">‚≠ê <span id="score">0</span></div>
        <div class="pill">üëÜ <span id="moves">0</span></div>
      </div>
    </div>
    <div class="controls">
      <select id="levelSel">
        <option value="baby">üë∂ Beb√©</option>
        <option value="easy">üê£ F√°cil</option>
        <option value="normal" selected>ü¶Ñ Normal</option>
      </select>
      <select id="themeSel">
        <option value="frutas">üçì Frutas</option>
        <option value="animales">üêµ Animales</option>
        <option value="caras">üòä Caras</option>
      </select>
      <button id="newBtn">‚ú® Nuevo</button>
      <button id="soundBtn">üîä</button>
      <button id="voiceBtn">üó£Ô∏è</button>
    </div>
  </header>

  <div class="board-wrap">
    <div id="board" class="board"></div>
  </div>

  <footer>
    <div class="lives-counter">‚ù§Ô∏è Vidas: <span id="livesLeft">5</span></div>
    <div class="timer-info" id="timerInfo" style="display: none;"></div>
    <div class="hint">‚ú® 2+ grupo ‚Ä¢ 4+ flecha ‚Ä¢ 5+ bal√≥n</div>
  </footer>

<script>
(function(){
  'use strict';
  
  // Configuraci√≥n
  const COLS = 6;
  const ROWS = 8;
  const MAX_LIVES = 5;
  const COOLDOWN_MINUTES = 25; // 25 minutos de espera

  const EMOJI_THEMES = {
    frutas: [
      { emoji: 'üçì', name: 'fresa' },
      { emoji: 'ü´ê', name: 'ar√°ndano' },
      { emoji: 'ü•ù', name: 'kiwi' },
      { emoji: 'üçå', name: 'pl√°tano' },
      { emoji: 'üçá', name: 'uvas' }
    ],
    animales: [
      { emoji: 'üêµ', name: 'mono' },
      { emoji: 'üê∏', name: 'rana' },
      { emoji: 'ü¶Å', name: 'le√≥n' },
      { emoji: 'üê•', name: 'pollito' },
      { emoji: 'üê∑', name: 'cerdito' }
    ],
    caras: [
      { emoji: 'üòä', name: 'feliz' },
      { emoji: 'üòé', name: 'cool' },
      { emoji: 'ü§ó', name: 'abrazo' },
      { emoji: 'üòã', name: 'rico' },
      { emoji: 'ü•≥', name: 'fiesta' }
    ]
  };

  const LEVELS = {
    baby: { target: 500, moves: 50 },
    easy: { target: 1500, moves: 35 },
    normal: { target: 3000, moves: 25 }
  };

  // Sistema de sonido
  class SoundSystem {
    constructor() {
      this.enabled = true;
      this.audioCtx = null;
      this.init();
    }

    init() {
      try {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        console.warn('Audio no disponible');
      }
    }

    play(freq, duration = 0.2) {
      if (!this.enabled || !this.audioCtx) return;
      try {
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.start();
        osc.stop(this.audioCtx.currentTime + duration);
      } catch (e) {}
    }

    playPop() { this.play(600, 0.1); }
    playSuccess() { 
      [523, 659, 784].forEach((f, i) => {
        setTimeout(() => this.play(f, 0.15), i * 50);
      });
    }
    playSpecial() {
      [392, 523, 659, 784, 659, 523].forEach((f, i) => {
        setTimeout(() => this.play(f, 0.1), i * 40);
      });
    }
    playError() { this.play(200, 0.3); }
  }

  // Sistema de voz
  class VoiceSystem {
    constructor() {
      this.enabled = false;
      this.synth = window.speechSynthesis;
    }

    speak(text, force = false) {
      if (!this.enabled && !force) return;
      if (!this.synth) return;
      
      try {
        this.synth.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'es-ES';
        utterance.pitch = 1.3;
        utterance.rate = 0.9;
        utterance.volume = 0.7;
        
        setTimeout(() => {
          this.synth.speak(utterance);
        }, 100);
      } catch (e) {}
    }

    toggle() {
      this.enabled = !this.enabled;
      if (this.enabled) {
        this.speak('¬°Voz activada!');
      }
      return this.enabled;
    }
  }

  // Estado del juego
  let state = {
    grid: [],
    score: 0,
    movesLeft: 25,
    target: 3000,
    level: 'normal',
    theme: 'frutas',
    animating: false,
    livesLeft: MAX_LIVES,
    lockedUntil: null
  };

  // Cargar estado guardado
  function loadState() {
    const saved = localStorage.getItem('gameState');
    if (saved) {
      const data = JSON.parse(saved);
      state.livesLeft = data.livesLeft || MAX_LIVES;
      state.lockedUntil = data.lockedUntil || null;
    }
  }

  function saveState() {
    localStorage.setItem('gameState', JSON.stringify({
      livesLeft: state.livesLeft,
      lockedUntil: state.lockedUntil
    }));
  }

  let currentTheme = EMOJI_THEMES.frutas;
  const soundSystem = new SoundSystem();
  const voiceSystem = new VoiceSystem();
  let timerInterval = null;

  // Elementos DOM
  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const movesEl = document.getElementById('moves');
  const targetEl = document.getElementById('target');
  const livesLeftEl = document.getElementById('livesLeft');
  const timerInfoEl = document.getElementById('timerInfo');
  const newBtn = document.getElementById('newBtn');
  const levelSel = document.getElementById('levelSel');
  const themeSel = document.getElementById('themeSel');
  const soundBtn = document.getElementById('soundBtn');
  const voiceBtn = document.getElementById('voiceBtn');

  // Renderizado
  function render(animateChanges = false) {
    boardEl.innerHTML = '';
    const fragment = document.createDocumentFragment();
    
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const cell = state.grid[y][x];
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.x = x;
        tile.dataset.y = y;
        
        if (!cell) {
          tile.style.visibility = 'hidden';
        } else {
          tile.classList.add(`c${cell.color}`);
          
          if (cell.kind === 'ball') {
            tile.classList.add('ball');
          } else if (cell.kind === 'arrow') {
            tile.classList.add('arrow', cell.direction);
          } else {
            tile.textContent = currentTheme[cell.color].emoji;
          }
          
          // Animaciones
          if (animateChanges && cell.fallFrom !== undefined) {
            const distance = (cell.fallFrom - y) * 50;
            tile.style.setProperty('--fall-distance', `${distance}px`);
            tile.style.setProperty('--fall-duration', `${0.3 + (cell.fallFrom - y) * 0.05}s`);
            tile.style.setProperty('--fall-delay', `${x * 0.02}s`);
            tile.classList.add('falling');
            delete cell.fallFrom;
          }
          
          if (animateChanges && cell.isNew) {
            tile.style.setProperty('--new-delay', `${(x * 0.03) + 0.1}s`);
            tile.classList.add('new-tile');
            delete cell.isNew;
          }
        }
        
        fragment.appendChild(tile);
      }
    }
    
    boardEl.appendChild(fragment);
  }

  // NUEVO: Dibujar rayos conectores
  function drawLightning(fromX, fromY, targets, color) {
    const fromTile = boardEl.querySelector(`[data-x="${fromX}"][data-y="${fromY}"]`);
    if (!fromTile) return;
    
    const fromRect = fromTile.getBoundingClientRect();
    const fromCenterX = fromRect.left + fromRect.width / 2;
    const fromCenterY = fromRect.top + fromRect.height / 2;
    
    const colors = ['#ff4d4f', '#3b82f6', '#22c55e', '#f59e0b', '#a855f7'];
    const strokeColor = colors[color];
    
    targets.forEach(([toX, toY]) => {
      const toTile = boardEl.querySelector(`[data-x="${toX}"][data-y="${toY}"]`);
      if (!toTile) return;
      
      const toRect = toTile.getBoundingClientRect();
      const toCenterX = toRect.left + toRect.width / 2;
      const toCenterY = toRect.top + toRect.height / 2;
      
      // Crear SVG para el rayo
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.classList.add('lightning');
      svg.style.position = 'fixed';
      svg.style.left = '0';
      svg.style.top = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';
      svg.style.color = strokeColor;
      
      // Crear path zigzag para el rayo
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      
      // Calcular puntos intermedios para zigzag
      const midX = (fromCenterX + toCenterX) / 2;
      const midY = (fromCenterY + toCenterY) / 2;
      const offset = 15;
      const zigX1 = midX + (Math.random() - 0.5) * offset;
      const zigY1 = midY + (Math.random() - 0.5) * offset;
      
      path.setAttribute('d', `M ${fromCenterX} ${fromCenterY} L ${zigX1} ${zigY1} L ${toCenterX} ${toCenterY}`);
      
      svg.appendChild(path);
      document.body.appendChild(svg);
      
      setTimeout(() => svg.remove(), 500);
    });
  }

  // Click en ficha
  boardEl.addEventListener('click', (e) => {
    if (state.animating) return;
    if (checkLocked()) return;
    
    const tile = e.target.closest('.tile');
    if (!tile) return;
    
    const x = parseInt(tile.dataset.x);
    const y = parseInt(tile.dataset.y);
    const cell = state.grid[y]?.[x];
    
    if (!cell) return;
    
    if (cell.kind === 'ball') {
      handleBallClick(x, y, cell.color);
    } else if (cell.kind === 'arrow') {
      handleArrowClick(x, y, cell.direction);
    } else {
      handleNormalClick(x, y, cell.color);
    }
  });

  // Manejar click normal
  function handleNormalClick(x, y, color) {
    const group = findGroup(x, y, color);
    
    if (group.length < 2) {
      const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
      if (tile) {
        tile.style.animation = 'bounce 0.3s';
        setTimeout(() => tile.style.animation = '', 300);
      }
      soundSystem.playError();
      return;
    }
    
    state.animating = true;
    spendMove();
    
    // GRUPO DE 5+ : Crear bal√≥n
    if (group.length >= 5) {
      animateExplosion(group.filter(([gx, gy]) => !(gx === x && gy === y)));
      
      setTimeout(() => {
        for (const [gx, gy] of group) {
          if (!(gx === x && gy === y)) {
            spawnParticles(gx, gy, color);
            state.grid[gy][gx] = null;
          }
        }
        
        state.grid[y][x] = { kind: 'ball', color: color };
        
        soundSystem.playSpecial();
        voiceSystem.speak('¬°Bal√≥n m√°gico!');
        showToast('‚öΩ ¬°Bal√≥n m√°gico!');
        
        applyGravity();
        fillEmpty();
        render(true);
        
        setTimeout(() => {
         state.animating = false;
         checkGameState();
       }, 600);
     }, 300);
     
     addScore(100 + group.length * 10);
     return;
   }
   
   // GRUPO DE 4: Crear flecha
   if (group.length === 4) {
     animateExplosion(group.filter(([gx, gy]) => !(gx === x && gy === y)));
     
     setTimeout(() => {
       for (const [gx, gy] of group) {
         if (!(gx === x && gy === y)) {
           spawnParticles(gx, gy, color);
           state.grid[gy][gx] = null;
         }
       }
       
       // Crear flecha con direcci√≥n aleatoria
       const direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
       state.grid[y][x] = { kind: 'arrow', direction: direction, color: color };
       
       soundSystem.playSuccess();
       voiceSystem.speak('¬°Flecha especial!');
       showToast(direction === 'horizontal' ? '‚û°Ô∏è ¬°Flecha horizontal!' : '‚¨ÜÔ∏è ¬°Flecha vertical!');
       
       applyGravity();
       fillEmpty();
       render(true);
       
       setTimeout(() => {
         state.animating = false;
         checkGameState();
       }, 600);
     }, 300);
     
     addScore(80);
     return;
   }
   
   // Grupo normal (2-3)
   animateExplosion(group);
   
   setTimeout(() => {
     for (const [gx, gy] of group) {
       spawnParticles(gx, gy, color);
       state.grid[gy][gx] = null;
     }
     
     soundSystem.playPop();
     
     if (group.length >= 3) {
       voiceSystem.speak('¬°Bien hecho!');
     }
     
     applyGravity();
     fillEmpty();
     render(true);
     
     setTimeout(() => {
       state.animating = false;
       checkGameState();
     }, 600);
   }, 300);
   
   addScore(group.length * 15);
 }

 // NUEVO: Manejar click en flecha
 function handleArrowClick(x, y, direction) {
   state.animating = true;
   spendMove();
   
   const targets = [];
   
   if (direction === 'horizontal') {
     // Eliminar toda la fila
     for (let px = 0; px < COLS; px++) {
       if (state.grid[y][px] && state.grid[y][px].kind === 'normal') {
         targets.push([px, y]);
       }
     }
     voiceSystem.speak('¬°Explosi√≥n horizontal!');
     showToast('‚û°Ô∏è ¬°Fila eliminada!');
   } else {
     // Eliminar toda la columna
     for (let py = 0; py < ROWS; py++) {
       if (state.grid[py][x] && state.grid[py][x].kind === 'normal') {
         targets.push([x, py]);
       }
     }
     voiceSystem.speak('¬°Explosi√≥n vertical!');
     showToast('‚¨ÜÔ∏è ¬°Columna eliminada!');
   }
   
   // Animar eliminaci√≥n de l√≠nea
   targets.forEach(([tx, ty]) => {
     const tile = boardEl.querySelector(`[data-x="${tx}"][data-y="${ty}"]`);
     if (tile) {
       tile.classList.add('line-clear');
     }
   });
   
   setTimeout(() => {
     // Eliminar la flecha
     state.grid[y][x] = null;
     
     // Eliminar objetivos
     for (const [tx, ty] of targets) {
       if (state.grid[ty] && state.grid[ty][tx]) {
         spawnParticles(tx, ty, state.grid[ty][tx].color);
         state.grid[ty][tx] = null;
       }
     }
     
     soundSystem.playSpecial();
     applyGravity();
     fillEmpty();
     render(true);
     
     setTimeout(() => {
       state.animating = false;
       checkGameState();
     }, 600);
   }, 500);
   
   addScore(targets.length * 30);
 }

 // Manejar click en bal√≥n CON RAYOS
 function handleBallClick(x, y, color) {
   state.animating = true;
   spendMove();
   
   const ballCluster = findBallCluster(x, y);
   
   if (ballCluster.length >= 2) {
     // Limpieza total
     voiceSystem.speak('¬°Explosi√≥n total!');
     
     setTimeout(() => {
       for (let py = 0; py < ROWS; py++) {
         for (let px = 0; px < COLS; px++) {
           if (state.grid[py][px]) {
             if (state.grid[py][px].kind === 'normal') {
               spawnParticles(px, py, state.grid[py][px].color);
               state.grid[py][px] = null;
             } else if (ballCluster.some(([bx, by]) => bx === px && by === py)) {
               state.grid[py][px] = null;
             }
           }
         }
       }
       
       soundSystem.playSpecial();
       applyGravity();
       fillEmpty();
       render(true);
       
       setTimeout(() => {
         state.animating = false;
         checkGameState();
       }, 600);
     }, 400);
     
     addScore(500);
   } else {
     // Eliminar todas las fichas del mismo color CON RAYOS
     const targets = [];
     for (let py = 0; py < ROWS; py++) {
       for (let px = 0; px < COLS; px++) {
         const cell = state.grid[py][px];
         if (cell && cell.kind === 'normal' && cell.color === color) {
           targets.push([px, py]);
         }
       }
     }
     
     // DIBUJAR RAYOS
     drawLightning(x, y, targets, color);
     
     // Animar explosi√≥n con delay
     setTimeout(() => {
       animateExplosion(targets);
       
       setTimeout(() => {
         state.grid[y][x] = null; // Eliminar el bal√≥n
         for (const [tx, ty] of targets) {
           spawnParticles(tx, ty, color);
           state.grid[ty][tx] = null;
         }
         
         soundSystem.playSpecial();
         voiceSystem.speak('¬°Explosi√≥n de color!');
         showToast(`‚öΩ ¬°${currentTheme[color].emoji} eliminados!`);
         
         applyGravity();
         fillEmpty();
         render(true);
         
         setTimeout(() => {
           state.animating = false;
           checkGameState();
         }, 600);
       }, 300);
     }, 200);
     
     addScore(targets.length * 25);
   }
 }

 // Gravedad
 function applyGravity() {
   for (let x = 0; x < COLS; x++) {
     const column = [];
     
     for (let y = 0; y < ROWS; y++) {
       if (state.grid[y][x]) {
         column.push({
           cell: state.grid[y][x],
           originalY: y
         });
       }
     }
     
     for (let y = 0; y < ROWS; y++) {
       state.grid[y][x] = null;
     }
     
     let writePos = ROWS - 1;
     for (let i = column.length - 1; i >= 0; i--) {
       const item = column[i];
       state.grid[writePos][x] = item.cell;
       
       if (writePos > item.originalY) {
         state.grid[writePos][x].fallFrom = item.originalY;
       }
       
       writePos--;
     }
   }
 }

 // Rellenar vac√≠os
 function fillEmpty() {
   for (let y = 0; y < ROWS; y++) {
     for (let x = 0; x < COLS; x++) {
       if (!state.grid[y][x]) {
         state.grid[y][x] = {
           kind: 'normal',
           color: Math.floor(Math.random() * 5),
           isNew: true
         };
       }
     }
   }
 }

 // Buscar grupo
 function findGroup(startX, startY, color) {
   const visited = new Set();
   const stack = [[startX, startY]];
   const group = [];
   
   while (stack.length > 0) {
     const [x, y] = stack.pop();
     const key = `${x},${y}`;
     
     if (visited.has(key)) continue;
     visited.add(key);
     
     const cell = state.grid[y]?.[x];
     if (!cell || cell.kind !== 'normal' || cell.color !== color) continue;
     
     group.push([x, y]);
     
     if (x > 0) stack.push([x - 1, y]);
     if (x < COLS - 1) stack.push([x + 1, y]);
     if (y > 0) stack.push([x, y - 1]);
     if (y < ROWS - 1) stack.push([x, y + 1]);
   }
   
   return group;
 }

 // Buscar cluster de balones
 function findBallCluster(startX, startY) {
   const visited = new Set();
   const stack = [[startX, startY]];
   const cluster = [];
   
   while (stack.length > 0) {
     const [x, y] = stack.pop();
     const key = `${x},${y}`;
     
     if (visited.has(key)) continue;
     visited.add(key);
     
     const cell = state.grid[y]?.[x];
     if (!cell || cell.kind !== 'ball') continue;
     
     cluster.push([x, y]);
     
     if (x > 0) stack.push([x - 1, y]);
     if (x < COLS - 1) stack.push([x + 1, y]);
     if (y > 0) stack.push([x, y - 1]);
     if (y < ROWS - 1) stack.push([x, y + 1]);
   }
   
   return cluster;
 }

 // Animaciones
 function animateExplosion(cells) {
   for (const [x, y] of cells) {
     const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
     if (tile) {
       tile.classList.add('exploding');
     }
   }
 }

 // Part√≠culas
 function spawnParticles(x, y, color) {
   const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
   if (!tile) return;
   
   const rect = tile.getBoundingClientRect();
   const colors = ['#ff4d4f', '#3b82f6', '#22c55e', '#f59e0b', '#a855f7'];
   
   for (let i = 0; i < 6; i++) {
     const particle = document.createElement('div');
     particle.className = 'particle';
     particle.style.left = rect.left + rect.width / 2 + 'px';
     particle.style.top = rect.top + rect.height / 2 + 'px';
     particle.style.background = colors[color];
     
     const angle = (Math.PI * 2 * i) / 6;
     const distance = 40 + Math.random() * 30;
     particle.style.setProperty('--dx', Math.cos(angle) * distance + 'px');
     particle.style.setProperty('--dy', Math.sin(angle) * distance + 'px');
     
     document.body.appendChild(particle);
     setTimeout(() => particle.remove(), 600);
   }
 }

 // UI
 function showToast(message) {
   const existing = document.querySelector('.toast');
   if (existing) existing.remove();
   
   const toast = document.createElement('div');
   toast.className = 'toast';
   toast.textContent = message;
   document.body.appendChild(toast);
   setTimeout(() => toast.remove(), 1500);
 }

 function addScore(points) {
   state.score += points;
   updateUI();
   showToast(`+${points} ‚≠ê`);
 }

 function spendMove() {
   if (state.movesLeft > 0) {
     state.movesLeft--;
     updateUI();
   }
 }

 function updateUI() {
   scoreEl.textContent = state.score;
   movesEl.textContent = state.movesLeft;
   targetEl.textContent = state.target;
   livesLeftEl.textContent = state.livesLeft;
 }

 // SISTEMA DE VIDAS MEJORADO
 function checkLocked() {
   if (state.lockedUntil) {
     const now = Date.now();
     if (now < state.lockedUntil) {
       showLockedModal();
       return true;
     } else {
       // El tiempo expir√≥, restaurar vidas
       state.lockedUntil = null;
       state.livesLeft = MAX_LIVES;
       saveState();
       timerInfoEl.style.display = 'none';
       return false;
     }
   }
   return false;
 }

 function consumeLife() {
   state.livesLeft--;
   saveState();
   updateUI();
   
   if (state.livesLeft <= 0) {
     // Bloquear por 25 minutos
     state.lockedUntil = Date.now() + (COOLDOWN_MINUTES * 60 * 1000);
     saveState();
     showLockedModal();
     startTimer();
   }
 }

 function showLockedModal() {
   voiceSystem.speak('¬°No hay m√°s vidas! Espera un poquito', true);
   
   const timeLeft = Math.ceil((state.lockedUntil - Date.now()) / 1000 / 60);
   
   const modal = document.createElement('div');
   modal.className = 'modal';
   modal.innerHTML = `
     <div class="modal-card">
       <div class="emoji">‚è∞</div>
       <h2>¬°Sin vidas!</h2>
       <p>Tienes que esperar ${timeLeft} minutos</p>
       <p>¬°Ve a jugar con tus juguetes!</p>
       <button onclick="this.closest('.modal').remove()">OK</button>
     </div>
   `;
   document.body.appendChild(modal);
 }

 function startTimer() {
   if (timerInterval) clearInterval(timerInterval);
   
   timerInterval = setInterval(() => {
     if (!state.lockedUntil) {
       clearInterval(timerInterval);
       timerInfoEl.style.display = 'none';
       return;
     }
     
     const now = Date.now();
     if (now >= state.lockedUntil) {
       // Tiempo cumplido
       state.lockedUntil = null;
       state.livesLeft = MAX_LIVES;
       saveState();
       updateUI();
       timerInfoEl.style.display = 'none';
       clearInterval(timerInterval);
       showToast('¬°Vidas restauradas! üéâ');
       voiceSystem.speak('¬°Ya puedes jugar otra vez!', true);
     } else {
       // Mostrar tiempo restante
       const seconds = Math.ceil((state.lockedUntil - now) / 1000);
       const minutes = Math.floor(seconds / 60);
       const secs = seconds % 60;
       timerInfoEl.textContent = `‚è∞ Espera: ${minutes}:${secs.toString().padStart(2, '0')}`;
       timerInfoEl.style.display = 'block';
     }
   }, 1000);
 }

 // Verificar estado del juego
 function checkGameState() {
   if (state.score >= state.target) {
     showWin();
   } else if (state.movesLeft === 0) {
     showGameOver();
   }
 }

 function showWin() {
   soundSystem.playSpecial();
   voiceSystem.speak('¬°Ganaste! ¬°Eres incre√≠ble!');
   
   // NO consumir vida al ganar
   const modal = document.createElement('div');
   modal.className = 'modal';
   modal.innerHTML = `
     <div class="modal-card">
       <div class="emoji">üèÜ</div>
       <h2>¬°VICTORIA!</h2>
       <p>¬°Conseguiste ${state.score} puntos!</p>
       <p>‚ù§Ô∏è Vidas: ${state.livesLeft}</p>
       <button onclick="window.startNewGame()">üéÆ Siguiente nivel</button>
     </div>
   `;
   document.body.appendChild(modal);
 }

 function showGameOver() {
   voiceSystem.speak('¬°Se acab√≥! Una vida menos');
   
   // Consumir una vida
   consumeLife();
   
   const modal = document.createElement('div');
   modal.className = 'modal';
   modal.innerHTML = `
     <div class="modal-card">
       <div class="emoji">üò¢</div>
       <h2>¬°Se acab√≥!</h2>
       <p>Conseguiste ${state.score} puntos</p>
       <p>Te faltan ${state.target - state.score} puntos</p>
       <p>‚ù§Ô∏è Vidas restantes: ${state.livesLeft}</p>
       ${state.livesLeft > 0 ? 
         '<button onclick="window.startNewGame()">üéÆ Reintentar</button>' :
         '<button onclick="this.closest(\'.modal\').remove()">OK</button>'
       }
     </div>
   `;
   document.body.appendChild(modal);
 }

 // Funci√≥n global para empezar nuevo juego
 window.startNewGame = function() {
   const modal = document.querySelector('.modal');
   if (modal) modal.remove();
   
   if (checkLocked()) return;
   
   init();
   showToast('¬°Nueva partida! üéÆ');
 };

 // Inicializaci√≥n
 function init() {
   state.level = levelSel.value;
   state.theme = themeSel.value;
   currentTheme = EMOJI_THEMES[state.theme];
   
   const config = LEVELS[state.level];
   state.target = config.target;
   state.movesLeft = config.moves;
   state.score = 0;
   state.animating = false;
   
   generateBoard();
   render(false);
   updateUI();
 }

 // Generaci√≥n de tablero
 function generateBoard() {
   state.grid = [];
   
   for (let y = 0; y < ROWS; y++) {
     state.grid[y] = [];
     for (let x = 0; x < COLS; x++) {
       let color;
       const forbidden = new Set();
       
       if (x >= 2 && 
           state.grid[y][x-1].color === state.grid[y][x-2].color) {
         forbidden.add(state.grid[y][x-1].color);
       }
       
       if (y >= 2 && 
           state.grid[y-1][x].color === state.grid[y-2][x].color) {
         forbidden.add(state.grid[y-1][x].color);
       }
       
       const availableColors = [0,1,2,3,4].filter(c => !forbidden.has(c));
       color = availableColors[Math.floor(Math.random() * availableColors.length)];
       
       state.grid[y][x] = {
         kind: 'normal',
         color: color
       };
     }
   }
   
   ensurePlayableMoves();
 }

 function ensurePlayableMoves() {
   let hasMove = false;
   
   for (let y = 0; y < ROWS && !hasMove; y++) {
     for (let x = 0; x < COLS && !hasMove; x++) {
       const group = findGroup(x, y, state.grid[y][x].color);
       if (group.length >= 2) {
         hasMove = true;
       }
     }
   }
   
   if (!hasMove) {
     const x = Math.floor(Math.random() * (COLS - 1));
     const y = Math.floor(Math.random() * ROWS);
     const color = state.grid[y][x].color;
     state.grid[y][x + 1].color = color;
   }
 }

 // Event listeners
 newBtn.addEventListener('click', () => {
   if (checkLocked()) return;
   
   if (state.score > 0) {
     if (!confirm('¬øEmpezar nueva partida? Perder√°s el progreso actual.')) {
       return;
     }
     // Solo consumir vida si abandonas
     consumeLife();
   }
   
   init();
   showToast('¬°Nueva partida! üéÆ');
 });

 levelSel.addEventListener('change', () => {
   init();
   showToast(`Nivel: ${levelSel.options[levelSel.selectedIndex].text}`);
 });

 themeSel.addEventListener('change', () => {
   currentTheme = EMOJI_THEMES[themeSel.value];
   render(false);
   showToast(`Tema: ${themeSel.options[themeSel.selectedIndex].text}`);
 });

 soundBtn.addEventListener('click', () => {
   soundSystem.enabled = !soundSystem.enabled;
   soundBtn.textContent = soundSystem.enabled ? 'üîä' : 'üîá';
   showToast(soundSystem.enabled ? 'Sonido ON' : 'Sonido OFF');
 });

 voiceBtn.addEventListener('click', () => {
   const enabled = voiceSystem.toggle();
   voiceBtn.textContent = enabled ? 'üó£Ô∏è' : 'üîï';
   showToast(enabled ? 'Voz ON' : 'Voz OFF');
 });

 // Iniciar
 loadState();
 if (state.lockedUntil && Date.now() < state.lockedUntil) {
   startTimer();
 }
 checkLocked();
 init();
 showToast('¬°Bienvenido! üåà');

})();
</script>
</body>
</html>
