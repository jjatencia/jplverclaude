<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Explota-Color üåà</title>
<style>
  :root {
    --bg: #0f172a;
    --gap: 6px;
    --radius: 14px;

    /* Colores vibrantes */
    --c0: #ff4d4f;
    --c1: #3b82f6;
    --c2: #22c55e;
    --c3: #f59e0b;
    --c4: #a855f7;

    --text: #e5e7eb;
    --muted: #9ca3af;
    
    /* Safe areas para iPhone */
    --safe-top: max(10px, env(safe-area-inset-top));
    --safe-bottom: max(10px, env(safe-area-inset-bottom));
    --safe-left: max(10px, env(safe-area-inset-left));
    --safe-right: max(10px, env(safe-area-inset-right));
  }

  * { 
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    margin: 0;
    padding: 0;
  }
  
  html { 
    height: 100%; 
    height: -webkit-fill-available;
  }
  
  body {
    min-height: 100vh;
    min-height: -webkit-fill-available;
    overflow: hidden;
    background: linear-gradient(180deg, #667eea, #764ba2);
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    display: flex;
    flex-direction: column;
    padding: var(--safe-top) var(--safe-left) var(--safe-bottom) var(--safe-right);
  }

  /* Header compacto para iPhone */
  header {
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 8px;
    margin-bottom: 8px;
  }

  .header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 6px;
  }

  .title {
    font-weight: 700;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .title .logo {
    font-size: 18px;
  }

  .level-indicator {
    background: linear-gradient(135deg, #ffd700, #ffed4e);
    color: #1a1a1a;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 800;
    margin-left: 6px;
  }

  .stats {
    display: flex;
    gap: 6px;
    font-size: 11px;
    font-weight: 600;
  }

  .pill {
    background: rgba(255,255,255,0.15);
    padding: 3px 8px;
    border-radius: 999px;
    display: flex;
    align-items: center;
    gap: 3px;
  }

  .timer-pill {
    background: linear-gradient(135deg, #ff4d4f, #ff6b6b);
    color: white;
    font-weight: 800;
    animation: timerPulse 1s ease-in-out infinite;
  }

  @keyframes timerPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  .controls {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }

  .controls select,
  .controls button {
    flex: 1;
    min-width: 0;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: #fff;
    font-weight: 600;
    font-size: 11px;
  }

  button:active {
    transform: scale(0.95);
  }

  /* Tablero responsive */
  .board-wrap {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 8px;
  }

  .board {
    --cols: 6;
    --rows: 8;
    width: 100%;
    max-width: 380px;
    aspect-ratio: 6/8;
    display: grid;
    grid-template-columns: repeat(var(--cols), 1fr);
    grid-template-rows: repeat(var(--rows), 1fr);
    gap: var(--gap);
    padding: 10px;
    border-radius: 16px;
    background: rgba(0,0,0,0.2);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  /* Fichas responsivas */
  .tile {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: min(5vw, 28px);
    border-radius: var(--radius);
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    cursor: pointer;
    transition: transform 0.15s;
    position: relative;
  }

  .tile:active {
    transform: scale(0.9);
  }

  /* Colores correctos - Solo los primeros 3 para nivel 1 */
  .c0 { background: linear-gradient(135deg, #ff6b6b, #ff4d4f); }
  .c1 { background: linear-gradient(135deg, #ffd93d, #f59e0b); }
  .c2 { background: linear-gradient(135deg, #4ecdc4, #3b82f6); }
  .c3 { background: linear-gradient(135deg, #4ade80, #22c55e); }
  .c4 { background: linear-gradient(135deg, #c77dff, #a855f7); }

  /* PELOTA ESPECIAL - Bal√≥n de f√∫tbol girando */
  .ball {
    background: conic-gradient(
      from 0deg,
      currentColor 0deg 30deg,
      white 30deg 60deg,
      currentColor 60deg 90deg,
      white 90deg 120deg,
      currentColor 120deg 150deg,
      white 150deg 180deg,
      currentColor 180deg 210deg,
      white 210deg 240deg,
      currentColor 240deg 270deg,
      white 270deg 300deg,
      currentColor 300deg 330deg,
      white 330deg 360deg
    ) !important;
    animation: rotateBall 2s linear infinite;
    box-shadow: 
      0 0 30px currentColor,
      0 0 50px currentColor,
      inset 0 0 20px rgba(0,0,0,0.3),
      0 4px 8px rgba(0,0,0,0.4);
    border: 2px solid rgba(255,255,255,0.3);
  }

  .ball.c0 { color: #ff4d4f; }
  .ball.c1 { color: #f59e0b; }
  .ball.c2 { color: #3b82f6; }
  .ball.c3 { color: #22c55e; }
  .ball.c4 { color: #a855f7; }

  .ball::before {
    content: '‚öΩ';
    font-size: 0.7em;
    position: absolute;
    animation: pulse 1s ease-in-out infinite;
  }

  @keyframes rotateBall {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.2); opacity: 1; }
  }

  /* FLECHA ESPECIAL */
  .arrow {
    background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
    animation: arrowPulse 1s ease-in-out infinite;
    box-shadow: 
      0 0 30px #ffd700,
      0 0 50px #ffd700,
      0 4px 8px rgba(0,0,0,0.4);
    border: 2px solid rgba(255,255,255,0.5);
  }

  .arrow::before {
    content: '';
    position: absolute;
    font-size: 0.8em;
    animation: arrowBounce 1s ease-in-out infinite;
  }

  .arrow.horizontal::before { content: '‚û°Ô∏è'; }
  .arrow.vertical::before { content: '‚¨ÜÔ∏è'; }

  @keyframes arrowPulse {
    0%, 100% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.1); filter: brightness(1.3); }
  }

  @keyframes arrowBounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-3px); }
  }

  /* RAYOS CONECTORES */
  .lightning {
    position: fixed;
    pointer-events: none;
    z-index: 9999;
    stroke: currentColor;
    stroke-width: 3;
    fill: none;
    filter: drop-shadow(0 0 10px currentColor);
    animation: lightningStrike 0.5s ease-out forwards;
  }

  @keyframes lightningStrike {
    0% { 
      opacity: 0; 
      stroke-width: 1;
      filter: drop-shadow(0 0 5px currentColor);
    }
    50% { 
      opacity: 1; 
      stroke-width: 4;
      filter: drop-shadow(0 0 20px currentColor);
    }
    100% { 
      opacity: 0; 
      stroke-width: 1;
      filter: drop-shadow(0 0 30px currentColor);
    }
  }

  /* ESQUIRLAS PARA MEGA EXPLOSI√ìN */
  .shard {
    position: fixed;
    width: 12px;
    height: 12px;
    pointer-events: none;
    z-index: 9999;
    animation: shardFly 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
  }

  @keyframes shardFly {
    0% {
      transform: translate(0, 0) scale(1) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translate(var(--dx), var(--dy)) scale(0) rotate(720deg);
      opacity: 0;
    }
  }

  /* ONDA EXPANSIVA MEJORADA */
  .mega-shockwave {
    position: fixed;
    left: 50%;
    top: 50%;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9998;
    background: radial-gradient(circle, transparent 30%, rgba(255,255,255,0.8) 35%, transparent 40%, rgba(255,255,255,0.6) 45%, transparent 50%);
    animation: megaShockwave 1s ease-out forwards;
  }

  @keyframes megaShockwave {
    0% {
      transform: translate(-50%, -50%) scale(0);
      opacity: 1;
    }
    100% {
      transform: translate(-50%, -50%) scale(100);
      opacity: 0;
    }
  }

  /* FLASH DE PANTALLA √âPICO */
  .mega-flash {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 9997;
    background: radial-gradient(ellipse at center, white, transparent 60%);
    animation: megaFlash 0.8s ease-out forwards;
  }

  @keyframes megaFlash {
    0% { opacity: 0; }
    20% { opacity: 1; }
    100% { opacity: 0; }
  }

  /* Animaci√≥n de ca√≠da */
  .falling {
    animation: fall var(--fall-duration, 0.3s) cubic-bezier(0.4, 0, 0.2, 1) both;
    animation-delay: var(--fall-delay, 0s);
  }

  @keyframes fall {
    from {
      transform: translateY(calc(var(--fall-distance, -50px) * -1));
      opacity: 0.5;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  /* Nueva ficha */
  .new-tile {
    animation: dropNew 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) both;
    animation-delay: var(--new-delay, 0s);
  }

  @keyframes dropNew {
    from {
      transform: translateY(-150%) scale(0.5) rotate(180deg);
      opacity: 0;
    }
    to {
      transform: translateY(0) scale(1) rotate(0deg);
      opacity: 1;
    }
  }

  /* Explosi√≥n */
  .exploding {
    animation: explode 0.3s ease-out forwards;
  }

  @keyframes explode {
    to {
      transform: scale(0);
      opacity: 0;
    }
  }

  /* Eliminaci√≥n de l√≠nea */
  .line-clear {
    animation: lineClear 0.5s ease-out forwards;
  }

  @keyframes lineClear {
    0% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.2); filter: brightness(2); }
    100% { transform: scale(0) rotate(180deg); opacity: 0; }
  }

  /* Toast */
  .toast {
    position: fixed;
    left: 50%;
    top: var(--safe-top);
    transform: translateX(-50%);
    background: rgba(255,255,255,0.95);
    color: #1a1a1a;
    padding: 8px 16px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 13px;
    z-index: 9999;
    animation: toastSlide 1.5s ease forwards;
  }

  @keyframes toastSlide {
    0% { transform: translateX(-50%) translateY(-100px); opacity: 0; }
    20%, 80% { transform: translateX(-50%) translateY(20px); opacity: 1; }
    100% { transform: translateX(-50%) translateY(-100px); opacity: 0; }
  }

  /* Modal */
  .modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    padding: 20px;
  }

  .modal-card {
    background: white;
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    color: #1a1a1a;
    max-width: 90%;
    animation: modalPop 0.3s ease;
    max-height: 80vh;
    overflow-y: auto;
  }

  @keyframes modalPop {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 {
    margin: 0 0 12px 0;
    font-size: 24px;
    color: #764ba2;
  }

  .modal .emoji {
    font-size: 48px;
    margin-bottom: 12px;
    animation: celebrateEmoji 1s ease-in-out infinite;
  }

  @keyframes celebrateEmoji {
    0%, 100% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.1) rotate(-10deg); }
    75% { transform: scale(1.1) rotate(10deg); }
  }

  .modal button {
    margin: 8px 4px;
    padding: 10px 20px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
  }

  .modal input {
    width: 100%;
    padding: 12px;
    margin: 8px 0;
    border: 2px solid #ddd;
    border-radius: 8px;
    font-size: 16px;
    text-align: center;
  }

  /* Footer */
  footer {
    text-align: center;
    font-size: 11px;
    padding: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 8px;
    margin-top: 8px;
  }

  .progress-bar {
    background: rgba(255,255,255,0.2);
    border-radius: 999px;
    height: 6px;
    margin: 8px 0;
    overflow: hidden;
  }

  .progress-fill {
    background: linear-gradient(90deg, #ffd700, #ffed4e);
    height: 100%;
    border-radius: inherit;
    transition: width 0.3s ease;
    min-width: 2px;
  }

  .level-info {
    color: #ffd93d;
    font-weight: 600;
    font-size: 12px;
    margin-bottom: 4px;
  }

  .hint {
    color: #4ade80;
    font-weight: 600;
  }

  /* Ranking */
  .ranking-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 16px;
  }

  .ranking-table th,
  .ranking-table td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid #ddd;
  }

  .ranking-table th {
    background: #f5f5f5;
    font-weight: 700;
  }

  .ranking-table tr:nth-child(even) {
    background: #f9f9f9;
  }

  .ranking-position {
    font-weight: 700;
    color: #764ba2;
  }

  .ranking-position.top3 {
    color: #ffd700;
  }

  /* Part√≠cula */
  .particle {
    position: fixed;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9998;
    animation: particle 0.6s ease-out forwards;
  }

  @keyframes particle {
    to {
      transform: translate(var(--dx), var(--dy)) scale(0);
      opacity: 0;
    }
  }

  /* Rebote */
  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
  }

  /* Media queries para iPhone */
  @media screen and (max-width: 390px) {
    .board {
      max-width: calc(100vw - 32px);
    }
    
    .tile {
      font-size: min(6vw, 24px);
    }
  }
</style>
</head>
<body>
  <header>
    <div class="header-row">
      <div class="title">
        <span class="logo">üåà</span>
        <span>Explota-Color</span>
        <span class="level-indicator" id="levelIndicator">Nivel 1</span>
      </div>
      <div class="stats">
        <div class="pill timer-pill">‚è∞ <span id="timeLeft">2:00</span></div>
        <div class="pill">üéØ <span id="target">3000</span></div>
        <div class="pill">‚≠ê <span id="score">0</span></div>
      </div>
    </div>
    <div class="controls">
      <select id="themeSel">
        <option value="frutas">üçì Frutas</option>
        <option value="animales">üêµ Animales</option>
        <option value="caras">üòä Caras</option>
      </select>
      <button id="soundBtn">üîä</button>
      <button id="voiceBtn">üó£Ô∏è</button>
      <button id="rankingBtn">üèÜ Ranking</button>
    </div>
  </header>

  <div class="board-wrap">
    <div id="board" class="board"></div>
  </div>

  <footer>
    <div class="level-info" id="levelInfo">Objetivo: 3000 puntos para pasar al Nivel 2</div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill" style="width: 0%"></div>
    </div>
    <div class="hint">‚ú® 2+ grupo ‚Ä¢ 4+ flecha ‚Ä¢ 5+ bal√≥n</div>
  </footer>

<script>
(function(){
  'use strict';
  
  // Configuraci√≥n
  const COLS = 6;
  const ROWS = 8;
  const LEVEL_TIME = 120; // 2 minutos por nivel

  // SISTEMA DE NIVELES PROGRESIVOS
  const GAME_LEVELS = [
    {
      level: 1,
      name: "Nivel 1",
      colors: 3, // Solo rojo, amarillo y azul
      target: 3000,
      description: "üåü ¬°Empezamos f√°cil!"
    },
    {
      level: 2,
      name: "Nivel 2",
      colors: 4, // A√±adimos verde
      target: 4000,
      description: "üåø ¬°Aparece el verde!"
    },
    {
      level: 3,
      name: "Nivel 3",
      colors: 5, // A√±adimos morado
      target: 5000,
      description: "üíú ¬°Todos los colores!"
    }
  ];

  const EMOJI_THEMES = {
    frutas: [
      { emoji: 'üçì', name: 'fresa' },     // Rojo
      { emoji: 'üçå', name: 'pl√°tano' },   // Amarillo  
      { emoji: 'ü´ê', name: 'ar√°ndano' },  // Azul
      { emoji: 'ü•ù', name: 'kiwi' },      // Verde
      { emoji: 'üçá', name: 'uvas' }       // Morado
    ],
    animales: [
      { emoji: 'ü¶Ä', name: 'cangrejo' },  // Rojo
      { emoji: 'üê•', name: 'pollito' },   // Amarillo
      { emoji: 'üê¨', name: 'delf√≠n' },    // Azul
      { emoji: 'üê∏', name: 'rana' },      // Verde
      { emoji: 'ü¶Ñ', name: 'unicornio' }  // Morado
    ],
    caras: [
      { emoji: 'üò°', name: 'enfadado' },  // Rojo
      { emoji: 'üòä', name: 'feliz' },     // Amarillo
      { emoji: 'üò¢', name: 'triste' },    // Azul
      { emoji: 'ü§¢', name: 'mareado' },   // Verde
      { emoji: 'üòà', name: 'diablillo' }  // Morado
    ]
  };

  // Sistema de sonido
  class SoundSystem {
    constructor() {
      this.enabled = true;
      this.audioCtx = null;
      this.init();
    }

    init() {
      try {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        console.warn('Audio no disponible');
      }
    }

    play(freq, duration = 0.2) {
      if (!this.enabled || !this.audioCtx) return;
      try {
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.start();
        osc.stop(this.audioCtx.currentTime + duration);
      } catch (e) {}
    }

    playPop() { this.play(600, 0.1); }
    playSuccess() { 
      [523, 659, 784].forEach((f, i) => {
        setTimeout(() => this.play(f, 0.15), i * 50);
      });
    }
    playSpecial() {
      [392, 523, 659, 784, 659, 523].forEach((f, i) => {
        setTimeout(() => this.play(f, 0.1), i * 40);
      });
    }
    playLevelUp() {
      [523, 587, 659, 784, 880, 1047].forEach((f, i) => {
        setTimeout(() => this.play(f, 0.2), i * 80);
      });
    }
    playError() { this.play(200, 0.3); }
    playTick() { this.play(800, 0.05); }
  }

  // Sistema de voz
  class VoiceSystem {
    constructor() {
      this.enabled = false;
      this.synth = window.speechSynthesis;
    }

    speak(text, force = false) {
      if (!this.enabled && !force) return;
      if (!this.synth) return;
      
      try {
        this.synth.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'es-ES';
        utterance.pitch = 1.3;
        utterance.rate = 0.9;
        utterance.volume = 0.7;
        
        setTimeout(() => {
          this.synth.speak(utterance);
        }, 100);
      } catch (e) {}
    }

    toggle() {
      this.enabled = !this.enabled;
      if (this.enabled) {
        this.speak('¬°Voz activada!');
      }
      return this.enabled;
    }
  }

  // Sistema de ranking
  class RankingSystem {
    constructor() {
      this.rankings = this.loadRankings();
    }

    loadRankings() {
      const saved = localStorage.getItem('gameRankings');
      return saved ? JSON.parse(saved) : [];
    }

    saveRankings() {
      localStorage.setItem('gameRankings', JSON.stringify(this.rankings));
    }

    addScore(playerName, totalScore, levelsCompleted) {
      const entry = {
        name: playerName,
        score: totalScore,
        levels: levelsCompleted,
        date: new Date().toLocaleDateString(),
        timestamp: Date.now()
      };

      this.rankings.push(entry);
      this.rankings.sort((a, b) => b.score - a.score);
      this.rankings = this.rankings.slice(0, 50); // Mantener solo top 50
      this.saveRankings();

      return this.rankings.findIndex(r => r.timestamp === entry.timestamp) + 1;
    }

    getTopScores(limit = 10) {
      return this.rankings.slice(0, limit);
    }

    getPlayerPosition(playerName) {
      return this.rankings.findIndex(r => r.name === playerName) + 1;
    }
  }

  // Estado del juego
  let state = {
    grid: [],
    score: 0,
    currentLevel: 1,
    theme: 'frutas',
    animating: false,
    gameActive: false,
    timeLeft: LEVEL_TIME,
    totalScore: 0,
    playerName: '',
    levelStartTime: 0,
    gameStarted: false
  };

  let currentTheme = EMOJI_THEMES.frutas;
  const soundSystem = new SoundSystem();
  const voiceSystem = new VoiceSystem();
  const rankingSystem = new RankingSystem();
  let gameTimer = null;

  // Elementos DOM
  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const targetEl = document.getElementById('target');
  const timeLeftEl = document.getElementById('timeLeft');
  const levelIndicatorEl = document.getElementById('levelIndicator');
  const levelInfoEl = document.getElementById('levelInfo');
  const progressFillEl = document.getElementById('progressFill');
  const themeSel = document.getElementById('themeSel');
  const soundBtn = document.getElementById('soundBtn');
  const voiceBtn = document.getElementById('voiceBtn');
  const rankingBtn = document.getElementById('rankingBtn');

  // Cargar datos del jugador
  function loadPlayerData() {
    const saved = localStorage.getItem('playerData');
    if (saved) {
      const data = JSON.parse(saved);
      state.playerName = data.playerName || '';
    }
  }

  function savePlayerData() {
    localStorage.setItem('playerData', JSON.stringify({
      playerName: state.playerName
    }));
  }

  // Obtener configuraci√≥n del nivel actual
  function getCurrentLevelConfig() {
    const index = Math.min(state.currentLevel - 1, GAME_LEVELS.length - 1);
    return GAME_LEVELS[index];
  }

  // Sistema de timer
  function startTimer() {
    if (gameTimer) clearInterval(gameTimer);
    
    gameTimer = setInterval(() => {
      if (state.gameActive) {
        state.timeLeft--;
        updateTimerDisplay();
        
        if (state.timeLeft <= 10) {
          soundSystem.playTick();
        }
        
        if (state.timeLeft <= 0) {
          endLevel();
        }
      }
    }, 1000);
  }

  function stopTimer() {
    if (gameTimer) {
      clearInterval(gameTimer);
      gameTimer = null;
    }
  }

  function updateTimerDisplay() {
    const minutes = Math.floor(state.timeLeft / 60);
    const seconds = state.timeLeft % 60;
    timeLeftEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    // Cambiar color cuando quedan menos de 30 segundos
    const timerPill = timeLeftEl.closest('.timer-pill');
    if (state.timeLeft <= 30) {
      timerPill.style.background = 'linear-gradient(135deg, #ff1744, #ff5722)';
    } else {
      timerPill.style.background = 'linear-gradient(135deg, #ff4d4f, #ff6b6b)';
    }
  }

  // Renderizado
  function render(animateChanges = false) {
    boardEl.innerHTML = '';
    const fragment = document.createDocumentFragment();
    
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const cell = state.grid[y][x];
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.x = x;
        tile.dataset.y = y;
        
        if (!cell) {
          tile.style.visibility = 'hidden';
        } else {
          tile.classList.add(`c${cell.color}`);
          
          if (cell.kind === 'ball') {
            tile.classList.add('ball');
          } else if (cell.kind === 'arrow') {
            tile.classList.add('arrow', cell.direction);
          } else {
            tile.textContent = currentTheme[cell.color].emoji;
          }
          
          // Animaciones
          if (animateChanges && cell.fallFrom !== undefined) {
            const distance = (cell.fallFrom - y) * 50;
            tile.style.setProperty('--fall-distance', `${distance}px`);
            tile.style.setProperty('--fall-duration', `${0.3 + (cell.fallFrom - y) * 0.05}s`);
            tile.style.setProperty('--fall-delay', `${x * 0.02}s`);
            tile.classList.add('falling');
            delete cell.fallFrom;
          }
          
          if (animateChanges && cell.isNew) {
            tile.style.setProperty('--new-delay', `${(x * 0.03) + 0.1}s`);
            tile.classList.add('new-tile');
            delete cell.isNew;
          }
        }
        
        fragment.appendChild(tile);
      }
    }
    
    boardEl.appendChild(fragment);
  }

  // Mega explosi√≥n con esquirlas
  function createMegaExplosion() {
    // Crear onda expansiva
    const shockwave = document.createElement('div');
    shockwave.className = 'mega-shockwave';
    document.body.appendChild(shockwave);
    setTimeout(() => shockwave.remove(), 1000);
    
    // Crear flash √©pico
    const flash = document.createElement('div');
    flash.className = 'mega-flash';
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 800);
    
    // Crear esquirlas por toda la pantalla
    const colors = ['#ff4d4f', '#f59e0b', '#3b82f6', '#22c55e', '#a855f7'];
    const boardRect = boardEl.getBoundingClientRect();
    const centerX = boardRect.left + boardRect.width / 2;
    const centerY = boardRect.top + boardRect.height / 2;
    
    // Crear muchas esquirlas
    for (let i = 0; i < 50; i++) {
      setTimeout(() => {
        const shard = document.createElement('div');
        shard.className = 'shard';
        shard.style.left = centerX + 'px';
        shard.style.top = centerY + 'px';
        
        // Color aleatorio
        const color = colors[Math.floor(Math.random() * colors.length)];
        shard.style.background = `linear-gradient(45deg, ${color}, white)`;
        shard.style.boxShadow = `0 0 20px ${color}`;
        
        // Direcci√≥n aleatoria en 360 grados
        const angle = (Math.PI * 2 * i) / 50 + (Math.random() - 0.5) * 0.5;
        const distance = 200 + Math.random() * 300;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        
        shard.style.setProperty('--dx', dx + 'px');
        shard.style.setProperty('--dy', dy + 'px');
        
        document.body.appendChild(shard);
        setTimeout(() => shard.remove(), 1200);
      }, i * 10);
    }
    
    // Vibraci√≥n √©pica
    if (navigator.vibrate) {
      navigator.vibrate([100, 50, 100, 50, 200]);
    }
  }

  // Click en ficha
  boardEl.addEventListener('click', (e) => {
    if (state.animating || !state.gameActive) return;
    
    const tile = e.target.closest('.tile');
    if (!tile) return;
    
    const x = parseInt(tile.dataset.x);
    const y = parseInt(tile.dataset.y);
    const cell = state.grid[y]?.[x];
    
    if (!cell) return;
    
    if (cell.kind === 'ball') {
      handleBallClick(x, y, cell.color);
    } else if (cell.kind === 'arrow') {
      handleArrowClick(x, y, cell.direction);
    } else {
      handleNormalClick(x, y, cell.color);
    }
  });

  // Manejar click normal
  function handleNormalClick(x, y, color) {
    const group = findGroup(x, y, color);
    
    if (group.length < 2) {
      const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
      if (tile) {
        tile.style.animation = 'bounce 0.3s';
        setTimeout(() => tile.style.animation = '', 300);
      }
      soundSystem.playError();
      return;
    }
    
    state.animating = true;
    
    // GRUPO DE 5+: Crear bal√≥n
    if (group.length >= 5) {
      animateExplosion(group.filter(([gx, gy]) => !(gx === x && gy === y)));
      
      setTimeout(() => {
        for (const [gx, gy] of group) {
          if (!(gx === x && gy === y)) {
            spawnParticles(gx, gy, color);
            state.grid[gy][gx] = null;
          }
        }
        
        state.grid[y][x] = { kind: 'ball', color: color };
        
        soundSystem.playSpecial();
        voiceSystem.speak('¬°Bal√≥n m√°gico!');
        showToast('‚öΩ ¬°Bal√≥n m√°gico!');
        
        applyGravity();
        fillEmpty();
        render(true);
        
        setTimeout(() => {
          state.animating = false;
        }, 600);
      }, 300);
      
      addScore(100 + group.length * 10);
      return;
    }
    
    // GRUPO DE 4: Crear flecha
    if (group.length === 4) {
      animateExplosion(group.filter(([gx, gy]) => !(gx === x && gy === y)));
      
      setTimeout(() => {
        for (const [gx, gy] of group) {
          if (!(gx === x && gy === y)) {
            spawnParticles(gx, gy, color);
            state.grid[gy][gx] = null;
          }
        }
        
        const direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
        state.grid[y][x] = { kind: 'arrow', direction: direction, color: color };
        
        soundSystem.playSuccess();
        voiceSystem.speak('¬°Flecha especial!');
        showToast(direction === 'horizontal' ? '‚û°Ô∏è ¬°Flecha horizontal!' : '‚¨ÜÔ∏è ¬°Flecha vertical!');
        
        applyGravity();
        fillEmpty();
        render(true);
        
        setTimeout(() => {
          state.animating = false;
        }, 600);
      }, 300);
      
      addScore(80);
      return;
    }
    
    // Grupo normal (2-3)
    animateExplosion(group);
    
    setTimeout(() => {
      for (const [gx, gy] of group) {
        spawnParticles(gx, gy, color);
        state.grid[gy][gx] = null;
      }
      
      soundSystem.playPop();
      
      if (group.length >= 3) {
        voiceSystem.speak('¬°Bien hecho!');
      }
      
      applyGravity();
      fillEmpty();
      render(true);
      
      setTimeout(() => {
        state.animating = false;
      }, 600);
    }, 300);
    
    addScore(group.length * 15);
  }

  // Manejar click en flecha
  function handleArrowClick(x, y, direction) {
    state.animating = true;
    
    const targets = [];
    
    if (direction === 'horizontal') {
      for (let px = 0; px < COLS; px++) {
        if (state.grid[y][px] && state.grid[y][px].kind === 'normal') {
          targets.push([px, y]);
        }
      }
      voiceSystem.speak('¬°Explosi√≥n horizontal!');
      showToast('‚û°Ô∏è ¬°Fila eliminada!');
    } else {
      for (let py = 0; py < ROWS; py++) {
        if (state.grid[py][x] && state.grid[py][x].kind === 'normal') {
          targets.push([x, py]);
        }
      }
      voiceSystem.speak('¬°Explosi√≥n vertical!');
      showToast('‚¨ÜÔ∏è ¬°Columna eliminada!');
    }
    
    targets.forEach(([tx, ty]) => {
      const tile = boardEl.querySelector(`[data-x="${tx}"][data-y="${ty}"]`);
      if (tile) {
        tile.classList.add('line-clear');
      }
    });
    
    setTimeout(() => {
      state.grid[y][x] = null;
      
      for (const [tx, ty] of targets) {
        if (state.grid[ty] && state.grid[ty][tx]) {
          spawnParticles(tx, ty, state.grid[ty][tx].color);
          state.grid[ty][tx] = null;
        }
      }
      
      soundSystem.playSpecial();
      applyGravity();
      fillEmpty();
      render(true);
      
      setTimeout(() => {
        state.animating = false;
      }, 600);
    }, 500);
    
    addScore(targets.length * 30);
  }

  // Manejar click en bal√≥n
  function handleBallClick(x, y, color) {
    state.animating = true;
    
    const ballCluster = findBallCluster(x, y);
    
    if (ballCluster.length >= 2) {
      // MEGA EXPLOSI√ìN √âPICA
      voiceSystem.speak('¬°Mega explosi√≥n!');
      showToast('üí• ¬°¬°¬°MEGA EXPLOSI√ìN!!! üí•');
      
      // Crear efectos especiales
      createMegaExplosion();
      
      setTimeout(() => {
        // Eliminar todo
        for (let py = 0; py < ROWS; py++) {
          for (let px = 0; px < COLS; px++) {
            if (state.grid[py][px]) {
              if (state.grid[py][px].kind === 'normal') {
                spawnParticles(px, py, state.grid[py][px].color);
                state.grid[py][px] = null;
              } else if (ballCluster.some(([bx, by]) => bx === px && by === py)) {
                state.grid[py][px] = null;
              }
            }
          }
        }
        
        soundSystem.playSpecial();
        applyGravity();
        fillEmpty();
        render(true);
        
        setTimeout(() => {
          state.animating = false;
        }, 600);
      }, 600);
      
      addScore(800);
    } else {
      // Eliminar color
      const targets = [];
      for (let py = 0; py < ROWS; py++) {
        for (let px = 0; px < COLS; px++) {
          const cell = state.grid[py][px];
          if (cell && cell.kind === 'normal' && cell.color === color) {
            targets.push([px, py]);
          }
        }
      }
      
      setTimeout(() => {
        animateExplosion(targets);
        
        setTimeout(() => {
          state.grid[y][x] = null;
          for (const [tx, ty] of targets) {
            spawnParticles(tx, ty, color);
            state.grid[ty][tx] = null;
          }
          
          soundSystem.playSpecial();
          voiceSystem.speak('¬°Explosi√≥n de color!');
          showToast(`‚öΩ ¬°${currentTheme[color].emoji} eliminados!`);
          
          applyGravity();
          fillEmpty();
          render(true);
          
          setTimeout(() => {
            state.animating = false;
          }, 600);
        }, 300);
      }, 200);
      
      addScore(targets.length * 25);
    }
  }

  // Gravedad
  function applyGravity() {
    for (let x = 0; x < COLS; x++) {
      const column = [];
      
      for (let y = 0; y < ROWS; y++) {
        if (state.grid[y][x]) {
          column.push({
            cell: state.grid[y][x],
            originalY: y
          });
        }
      }
      
      for (let y = 0; y < ROWS; y++) {
        state.grid[y][x] = null;
      }
      
      let writePos = ROWS - 1;
      for (let i = column.length - 1; i >= 0; i--) {
        const item = column[i];
        state.grid[writePos][x] = item.cell;
        
        if (writePos > item.originalY) {
          state.grid[writePos][x].fallFrom = item.originalY;
        }
        
        writePos--;
      }
    }
  }

  // Rellenar vac√≠os
  function fillEmpty() {
    const levelConfig = getCurrentLevelConfig();
    const maxColors = levelConfig.colors;
    
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (!state.grid[y][x]) {
          state.grid[y][x] = {
            kind: 'normal',
            color: Math.floor(Math.random() * maxColors),
            isNew: true
          };
        }
      }
    }
  }

  // Buscar grupo
  function findGroup(startX, startY, color) {
    const visited = new Set();
    const stack = [[startX, startY]];
    const group = [];
    
    while (stack.length > 0) {
      const [x, y] = stack.pop();
      const key = `${x},${y}`;
      
      if (visited.has(key)) continue;
      visited.add(key);
      
      const cell = state.grid[y]?.[x];
      if (!cell || cell.kind !== 'normal' || cell.color !== color) continue;
      
      group.push([x, y]);
      
      if (x > 0) stack.push([x - 1, y]);
      if (x < COLS - 1) stack.push([x + 1, y]);
      if (y > 0) stack.push([x, y - 1]);
      if (y < ROWS - 1) stack.push([x, y + 1]);
    }
    
    return group;
  }

  // Buscar cluster de balones
  function findBallCluster(startX, startY) {
    const visited = new Set();
    const stack = [[startX, startY]];
    const cluster = [];
    
    while (stack.length > 0) {
      const [x, y] = stack.pop();
      const key = `${x},${y}`;
      
      if (visited.has(key)) continue;
      visited.add(key);
      
      const cell = state.grid[y]?.[x];
      if (!cell || cell.kind !== 'ball') continue;
      
      cluster.push([x, y]);
      
      if (x > 0) stack.push([x - 1, y]);
      if (x < COLS - 1) stack.push([x + 1, y]);
      if (y > 0) stack.push([x, y - 1]);
      if (y < ROWS - 1) stack.push([x, y + 1]);
    }
    
    return cluster;
  }

  // Animaciones
  function animateExplosion(cells) {
    for (const [x, y] of cells) {
      const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
      if (tile) {
        tile.classList.add('exploding');
      }
    }
  }

  // Part√≠culas
  function spawnParticles(x, y, color) {
    const tile = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
    if (!tile) return;
    
    const rect = tile.getBoundingClientRect();
    const colors = ['#ff4d4f', '#f59e0b', '#3b82f6', '#22c55e', '#a855f7'];
    
    for (let i = 0; i < 6; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.left = rect.left + rect.width / 2 + 'px';
      particle.style.top = rect.top + rect.height / 2 + 'px';
      particle.style.background = colors[color];
      
      const angle = (Math.PI * 2 * i) / 6;
      const distance = 40 + Math.random() * 30;
      particle.style.setProperty('--dx', Math.cos(angle) * distance + 'px');
      particle.style.setProperty('--dy', Math.sin(angle) * distance + 'px');
      
      document.body.appendChild(particle);
      setTimeout(() => particle.remove(), 600);
    }
  }

  // UI
  function showToast(message) {
    const existing = document.querySelector('.toast');
    if (existing) existing.remove();
    
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 4000);
  }

  function addScore(points) {
    state.score += points;
    updateUI();
    showToast(`+${points} ‚≠ê`);
  }

  function updateUI() {
    scoreEl.textContent = state.score;
    targetEl.textContent = getCurrentLevelConfig().target;
    levelIndicatorEl.textContent = `Nivel ${state.currentLevel}`;
    
    const levelConfig = getCurrentLevelConfig();
    const progress = Math.min((state.score / levelConfig.target) * 100, 100);
    progressFillEl.style.width = progress + '%';
    
    if (state.score >= levelConfig.target) {
      levelInfoEl.textContent = `¬°Objetivo conseguido! Sigue sumando puntos...`;
      levelInfoEl.style.color = '#4ade80';
    } else {
      const remaining = levelConfig.target - state.score;
      levelInfoEl.textContent = `Objetivo: ${remaining} puntos m√°s para pasar al Nivel ${state.currentLevel + 1}`;
      levelInfoEl.style.color = '#ffd93d';
    }
  }

  // Finalizar nivel
  function endLevel() {
    state.gameActive = false;
    stopTimer();
    
    const levelConfig = getCurrentLevelConfig();
    const targetReached = state.score >= levelConfig.target;
    
    state.totalScore += state.score;
    
    if (targetReached && state.currentLevel < GAME_LEVELS.length) {
      // Pasar al siguiente nivel
      soundSystem.playLevelUp();
      state.currentLevel++;
      
      const nextLevel = getCurrentLevelConfig();
      voiceSystem.speak(`¬°Nivel ${state.currentLevel}! ${nextLevel.description}`, true);
      
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div class="modal-card">
          <div class="emoji">üéâ</div>
          <h2>¬°Nivel Completado!</h2>
          <p>¬°Conseguiste ${state.score} puntos!</p>
          <p><strong>${nextLevel.description}</strong></p>
          <p>Puntuaci√≥n total: ${state.totalScore} ‚≠ê</p>
          <button onclick="nextLevel()">üöÄ Siguiente Nivel</button>
        </div>
      `;
      document.body.appendChild(modal);
    } else if (state.currentLevel >= GAME_LEVELS.length) {
      // Juego completado
      finishGame();
    } else {
      // No alcanz√≥ el objetivo
      finishGame();
    }
  }

  function finishGame() {
    soundSystem.playLevelUp();
    
    let levelsCompleted = state.currentLevel;
    const lastLevelConfig = getCurrentLevelConfig();
    
    // Si no alcanz√≥ el objetivo del √∫ltimo nivel, no cuenta como completado
    if (state.score < lastLevelConfig.target) {
      levelsCompleted = Math.max(1, state.currentLevel - 1);
    }
    
    const position = rankingSystem.addScore(state.playerName, state.totalScore, levelsCompleted);
    
    let message = '';
    if (levelsCompleted >= GAME_LEVELS.length) {
      message = '¬°Felicidades! ¬°Completaste todos los niveles!';
      voiceSystem.speak('¬°Felicidades! ¬°Completaste todos los niveles!', true);
    } else {
      message = `¬°Buen intento! Llegaste al nivel ${levelsCompleted}`;
      voiceSystem.speak(`¬°Buen intento! Llegaste al nivel ${levelsCompleted}`, true);
    }
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-card">
        <div class="emoji">${levelsCompleted >= GAME_LEVELS.length ? 'üèÜ' : 'üéÆ'}</div>
        <h2>${levelsCompleted >= GAME_LEVELS.length ? '¬°JUEGO COMPLETADO!' : '¬°Partida Terminada!'}</h2>
        <p>${message}</p>
        <p><strong>Puntuaci√≥n total: ${state.totalScore} ‚≠ê</strong></p>
        <p>Posici√≥n en ranking: #${position}</p>
        <div style="margin-top: 16px;">
          <button onclick="showRanking()">üèÜ Ver Ranking</button>
          <button onclick="startNewGame()">üéÆ Nueva Partida</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }

  // Mostrar ranking
  function showRanking() {
    const topScores = rankingSystem.getTopScores();
    
    let rankingHTML = `
      <div class="modal-card">
        <h2>üèÜ Ranking</h2>
        <table class="ranking-table">
          <thead>
            <tr>
              <th>Pos</th>
              <th>Jugador</th>
              <th>Puntos</th>
              <th>Niveles</th>
              <th>Fecha</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    if (topScores.length === 0) {
      rankingHTML += `
        <tr>
          <td colspan="5" style="text-align: center; padding: 20px;">
            ¬°S√© el primero en aparecer en el ranking!
          </td>
        </tr>
      `;
    } else {
      topScores.forEach((entry, index) => {
        const position = index + 1;
        const positionClass = position <= 3 ? 'top3' : '';
        rankingHTML += `
          <tr>
            <td class="ranking-position ${positionClass}">#${position}</td>
            <td>${entry.name}</td>
            <td>${entry.score}</td>
            <td>${entry.levels}/3</td>
            <td>${entry.date}</td>
          </tr>
        `;
      });
    }
    
    rankingHTML += `
          </tbody>
        </table>
        <div style="margin-top: 16px;">
          <button onclick="this.closest('.modal').remove()">Cerrar</button>
        </div>
      </div>
    `;
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = rankingHTML;
    document.body.appendChild(modal);
  }

  // Pedir nombre de jugador
  function askPlayerName() {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-card">
        <div class="emoji">üåà</div>
        <h2>¬°Bienvenido a Explota-Color!</h2>
        <p>¬øC√≥mo te llamas?</p>
        <input type="text" id="playerNameInput" placeholder="Tu nombre" maxlength="20">
        <div>
          <button onclick="setPlayerName()">üéÆ ¬°Empezar a jugar!</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    
    const input = document.getElementById('playerNameInput');
    input.focus();
    
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        setPlayerName();
      }
    });
  }

  // Funciones globales
  function setPlayerName() {
    const input = document.getElementById('playerNameInput');
    const name = input.value.trim();
    
    if (name.length < 2) {
      input.style.borderColor = '#ff4d4f';
      input.placeholder = '¬°Necesitas al menos 2 letras!';
      return;
    }
    
    state.playerName = name;
    savePlayerData();
    
    const modal = document.querySelector('.modal');
    if (modal) modal.remove();
    
    showGameInstructions();
  }

  function showGameInstructions() {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-card">
        <div class="emoji">üéØ</div>
        <h2>¬øC√≥mo jugar?</h2>
        <p style="text-align: left; margin: 16px 0;">
          üïê <strong>2 minutos</strong> por nivel<br>
          üéØ <strong>Objetivos:</strong><br>
          ‚Ä¢ Nivel 1: 3000 puntos<br>
          ‚Ä¢ Nivel 2: 4000 puntos<br>
          ‚Ä¢ Nivel 3: 5000 puntos<br><br>
          ‚ú® <strong>Consejos:</strong><br>
          ‚Ä¢ 2+ fichas iguales = grupo<br>
          ‚Ä¢ 4 fichas = flecha especial<br>
          ‚Ä¢ 5+ fichas = bal√≥n m√°gico<br>
          ‚Ä¢ Sigue jugando tras conseguir el objetivo
        </p>
        <button onclick="startNewGame()">üöÄ ¬°Empezar!</button>
      </div>
    `;
    document.body.appendChild(modal);
  }

  function nextLevel() {
    const modal = document.querySelector('.modal');
    if (modal) modal.remove();
    
    // Resetear puntuaci√≥n del nivel pero mantener total
    state.score = 0;
    state.timeLeft = LEVEL_TIME;
    state.gameActive = true;
    
    init();
    startTimer();
    showToast(`¬°Nivel ${state.currentLevel}! üöÄ`);
  }

  function startNewGame() {
    const modal = document.querySelector('.modal');
    if (modal) modal.remove();
    
    // Reset completo
    state.currentLevel = 1;
    state.totalScore = 0;
    state.score = 0;
    state.timeLeft = LEVEL_TIME;
    state.gameActive = true;
    state.gameStarted = true;
    
    init();
    startTimer();
    showToast('¬°Nueva partida! üéÆ');
  }

  // Inicializaci√≥n
  function init() {
    const levelConfig = getCurrentLevelConfig();
    
    state.theme = themeSel.value;
    currentTheme = EMOJI_THEMES[state.theme];
    
    state.animating = false;
    
    generateBoard();
    render(false);
    updateUI();
    updateTimerDisplay();
  }

  // Generaci√≥n de tablero con colores seg√∫n nivel
  function generateBoard() {
    const levelConfig = getCurrentLevelConfig();
    const maxColors = levelConfig.colors;
    
    state.grid = [];
    
    for (let y = 0; y < ROWS; y++) {
      state.grid[y] = [];
      for (let x = 0; x < COLS; x++) {
        let color;
        const forbidden = new Set();
        
        if (x >= 2 && 
            state.grid[y][x-1].color === state.grid[y][x-2].color) {
          forbidden.add(state.grid[y][x-1].color);
        }
        
        if (y >= 2 && 
            state.grid[y-1] && state.grid[y-1][x] &&
            state.grid[y-2] && state.grid[y-2][x] &&
            state.grid[y-1][x].color === state.grid[y-2][x].color) {
          forbidden.add(state.grid[y-1][x].color);
        }
        
        const availableColors = [];
        for (let c = 0; c < maxColors; c++) {
          if (!forbidden.has(c)) availableColors.push(c);
        }
        
        color = availableColors[Math.floor(Math.random() * availableColors.length)];
        
        state.grid[y][x] = {
          kind: 'normal',
          color: color
        };
      }
    }
    
    ensurePlayableMoves();
  }

  function ensurePlayableMoves() {
    let hasMove = false;
    
    for (let y = 0; y < ROWS && !hasMove; y++) {
      for (let x = 0; x < COLS && !hasMove; x++) {
        const group = findGroup(x, y, state.grid[y][x].color);
        if (group.length >= 2) {
          hasMove = true;
        }
      }
    }
    
    if (!hasMove) {
      const x = Math.floor(Math.random() * (COLS - 1));
      const y = Math.floor(Math.random() * ROWS);
      const color = state.grid[y][x].color;
      state.grid[y][x + 1].color = color;
    }
  }

  // Event listeners
  themeSel.addEventListener('change', () => {
    currentTheme = EMOJI_THEMES[themeSel.value];
    render(false);
    showToast(`Tema: ${themeSel.options[themeSel.selectedIndex].text}`);
  });

  soundBtn.addEventListener('click', () => {
    soundSystem.enabled = !soundSystem.enabled;
    soundBtn.textContent = soundSystem.enabled ? 'üîä' : 'üîá';
    showToast(soundSystem.enabled ? 'Sonido ON' : 'Sonido OFF');
  });

  voiceBtn.addEventListener('click', () => {
    const enabled = voiceSystem.toggle();
    voiceBtn.textContent = enabled ? 'üó£Ô∏è' : 'üîï';
    showToast(enabled ? 'Voz ON' : 'Voz OFF');
  });

  rankingBtn.addEventListener('click', () => {
    showRanking();
  });

  // Prevenir que el juego se pause al cambiar de pesta√±a
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && state.gameActive) {
      // El usuario volvi√≥ a la pesta√±a, continuar el juego normalmente
    }
  });

  // Hacer funciones globales
  window.setPlayerName = setPlayerName;
  window.startNewGame = startNewGame;
  window.nextLevel = nextLevel;
  window.showRanking = showRanking;

  // Iniciar aplicaci√≥n
  loadPlayerData();
  
  if (!state.playerName) {
    askPlayerName();
  } else {
    // Mostrar pantalla de inicio
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-card">
        <div class="emoji">üåà</div>
        <h2>¬°Hola ${state.playerName}!</h2>
        <p>¬øListo para una nueva partida?</p>
        <div>
          <button onclick="startNewGame()">üéÆ Nueva Partida</button>
          <button onclick="showRanking()">üèÜ Ver Ranking</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
  }

  // Inicializar tablero (sin empezar el juego)
  init();

})();
</script>
</body>
</html>
